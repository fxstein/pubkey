#!/bin/zsh
# todo - AI-Agent First TODO List Tracker
# 
# Copyright 2025 Oliver Ratzesberger
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# AI-agent first TODO list management tool
# Keep AI agents on track and help humans supervise their work
#
# Version: 2.7.1
# Repository: https://github.com/fxstein/todo.ai
# Update: ./todo.ai update

set -e
set +x  # Explicitly disable debug/trace output

# Cross-platform sed in-place editing function
sed_inplace() {
    if [[ "$(uname)" == "Darwin" ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

# Version
VERSION="2.7.1"
REPO_URL="https://github.com/fxstein/todo.ai"
SCRIPT_URL="https://raw.githubusercontent.com/fxstein/todo.ai/main/todo.ai"

# Configuration
# Can be overridden with environment variables
TODO_FILE="${TODO_FILE:-$(pwd)/TODO.md}"
SERIAL_FILE="${TODO_SERIAL:-$(pwd)/.todo.ai/.todo.ai.serial}"
LOG_FILE="${TODO_LOG:-$(pwd)/.todo.ai/.todo.ai.log}"
CONFIG_FILE="${TODO_CONFIG:-$(pwd)/.todo.ai/config.yaml}"

# ============================================================================
# Hybrid Task Numbering System
# ============================================================================

# Configuration file path
get_config_file() {
    echo "$CONFIG_FILE"
}

# Read YAML config value (supports nested keys like coordination.type)
# 
# IMPORTANT YAML PARSING POLICY:
# ==============================
# This function and ALL YAML operations in this script ALWAYS use sed fallback when YAML parsers are missing.
# NEVER show errors for missing YAML parsers (yq, python3-yaml) - always provide sed fallback.
# This ensures the tool works on any system with basic shell utilities (sed, grep) without requiring
# external YAML parsing tools.
#
get_config_value() {
    local key="$1"  # e.g., "mode" or "coordination.type"
    local config_file=$(get_config_file)
    local default="${2:-}"
    
    if [[ ! -f "$config_file" ]]; then
        echo "$default"
        return 0
    fi
    
    # Try yq first (best YAML parser)
    if command -v yq >/dev/null 2>&1; then
        local value=$(yq eval ".$key" "$config_file" 2>/dev/null || echo "")
        if [[ -n "$value" ]] && [[ "$value" != "null" ]]; then
            echo "$value"
            return 0
        fi
    fi
    
    # Fallback to Python if available (with yaml module)
    if command -v python3 >/dev/null 2>&1 && python3 -c "import yaml" 2>/dev/null; then
        local value=$(python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f)
        if config is None:
            print('')
            sys.exit(0)
        # Handle nested keys (e.g., "coordination.type")
        keys = '$key'.split('.')
        value = config
        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]
            else:
                print('')
                sys.exit(0)
        print(str(value) if value is not None else '')
except Exception as e:
    print('')
    sys.exit(1)
EOF
)
        if [[ -n "$value" ]]; then
            echo "$value"
            return 0
        fi
    fi
    
    # Fallback to sed for nested keys (e.g., coordination.type, coordination.issue_number)
    if [[ "$key" =~ ^([^.]+)\.(.+)$ ]]; then
        local parent_key="${match[1]}"  # BASH_CONVERT: BASH_REMATCH[1]
        local child_key="${match[2]}"   # BASH_CONVERT: BASH_REMATCH[2]
        
        # Find the parent section (e.g., "coordination:")
        local in_section=false
        while IFS= read -r line; do
            # Check if we're entering the parent section
            if [[ "$line" =~ ^${parent_key}: ]]; then
                in_section=true
                continue
            fi
            
            # If we hit another top-level key, we've left the section
            if [[ "$in_section" == true ]] && [[ "$line" =~ ^[a-z_]+: ]]; then
                break
            fi
            
            # If we're in the section, look for the child key
            if [[ "$in_section" == true ]] && [[ "$line" =~ ^[[:space:]]+${child_key}:[[:space:]]*(.+)$ ]]; then
                local value="${match[1]}"  # BASH_CONVERT: BASH_REMATCH[1]
                # Remove quotes if present
                value=$(echo "$value" | sed 's/^"\(.*\)"$/\1/' | sed "s/^'\(.*\)'$/\1/" | sed 's/[[:space:]]*$//')
                if [[ -n "$value" ]] && [[ "$value" != "null" ]]; then
                    echo "$value"
                    return 0
                fi
            fi
        done < "$config_file"
    fi
    
    # Handle simple keys (not nested) - check after nested key handling
    # Use string contains check instead of regex for better compatibility
    if [[ "$key" != *.* ]]; then
        # Simple key (not nested) - use grep and sed
        local value=$(grep "^${key}:" "$config_file" 2>/dev/null | sed "s/^${key}:[[:space:]]*//" | sed 's/[[:space:]]*$//' | head -1)
        if [[ -n "$value" ]] && [[ "$value" != "null" ]]; then
            echo "$value"
            return 0
        fi
    fi
    
    echo "$default"
}

# Get numbering mode (default: single-user)
get_numbering_mode() {
    get_config_value "mode" "single-user"
}

# Validate configuration
validate_config() {
    local config_file=$(get_config_file)
    
    if [[ ! -f "$config_file" ]]; then
        # No config file is valid (defaults to single-user)
        return 0
    fi
    
    local mode=$(get_numbering_mode)
    
    # Check mode is valid
    case "$mode" in
        "single-user"|"multi-user"|"branch"|"enhanced")
            ;;
        *)
            echo "ERROR: Invalid mode in config: $mode" >&2
            echo "Valid modes: single-user, multi-user, branch, enhanced" >&2
            return 1
            ;;
    esac
    
    # Validate coordination settings if enhanced mode or single-user mode with coordination
    if [[ "$mode" == "enhanced" ]] || [[ "$mode" == "single-user" ]]; then
        local coord_type=$(get_config_value "coordination.type" "")
        if [[ "$coord_type" != "none" ]] && [[ -n "$coord_type" ]]; then
            case "$coord_type" in
                "github-issues")
                    local issue_num=$(get_config_value "coordination.issue_number" "")
                    if [[ -z "$issue_num" ]] || ! [[ "$issue_num" =~ ^[0-9]+$ ]]; then
                        echo "ERROR: Invalid or missing coordination.issue_number for github-issues mode" >&2
                        return 1
                    fi
                    ;;
                "counterapi")
                    local namespace=$(get_config_value "coordination.namespace" "")
                    if [[ -z "$namespace" ]]; then
                        echo "ERROR: Missing coordination.namespace for counterapi mode" >&2
                        return 1
                    fi
                    ;;
                *)
                    echo "ERROR: Invalid coordination.type: $coord_type" >&2
                    echo "Valid types: github-issues, counterapi, none" >&2
                    return 1
                    ;;
            esac
        fi
    fi
    
    return 0
}

# Create backup before mode switching
create_mode_backup() {
    local backup_dir="$(pwd)/.todo.ai/backups"
    local timestamp=$(date +"%Y%m%d%H%M%S")
    local backup_name="mode-switch-${timestamp}"
    
    # Ensure backup directory exists
    mkdir -p "$backup_dir" 2>/dev/null || return 1
    
    # Create backup of TODO.md and config.yaml
    local backup_todo="${backup_dir}/${backup_name}.TODO.md"
    local backup_config="${backup_dir}/${backup_name}.config.yaml"
    local backup_serial="${backup_dir}/${backup_name}.serial"
    
    # Copy files
    if [[ -f "$TODO_FILE" ]]; then
        cp "$TODO_FILE" "$backup_todo" 2>/dev/null || return 1
    fi
    
    local config_file=$(get_config_file)
    if [[ -f "$config_file" ]]; then
        cp "$config_file" "$backup_config" 2>/dev/null || return 1
    fi
    
    if [[ -f "$SERIAL_FILE" ]]; then
        cp "$SERIAL_FILE" "$backup_serial" 2>/dev/null || return 1
    fi
    
    echo "$backup_name"
    return 0
}

# Rollback from backup
rollback_from_backup() {
    local backup_name="$1"
    
    if [[ -z "$backup_name" ]]; then
        echo "Error: Please provide backup name"
        echo "Usage: ./todo.ai rollback-mode <backup-name>"
        echo "List backups: ./todo.ai list-mode-backups"
        return 1
    fi
    
    local backup_dir="$(pwd)/.todo.ai/backups"
    local backup_todo="${backup_dir}/${backup_name}.TODO.md"
    local backup_config="${backup_dir}/${backup_name}.config.yaml"
    local backup_serial="${backup_dir}/${backup_name}.serial"
    
    # Check if backup exists
    if [[ ! -f "$backup_todo" ]]; then
        echo "Error: Backup '$backup_name' not found"
        return 1
    fi
    
    # Restore files
    if [[ -f "$backup_todo" ]]; then
        cp "$backup_todo" "$TODO_FILE" 2>/dev/null || {
            echo "Error: Could not restore TODO.md"
            return 1
        }
    fi
    
    local config_file=$(get_config_file)
    if [[ -f "$backup_config" ]]; then
        cp "$backup_config" "$config_file" 2>/dev/null || {
            echo "Error: Could not restore config.yaml"
            return 1
        }
    elif [[ -f "$config_file" ]]; then
        # If backup has no config but current has one, remove it
        rm -f "$config_file" 2>/dev/null || true
    fi
    
    if [[ -f "$backup_serial" ]]; then
        cp "$backup_serial" "$SERIAL_FILE" 2>/dev/null || {
            echo "Error: Could not restore serial file"
            return 1
        }
    fi
    
    echo "‚úÖ Rollback complete: restored from backup '$backup_name'"
    return 0
}

# List mode backups
list_mode_backups() {
    local backup_dir="$(pwd)/.todo.ai/backups"
    
    if [[ ! -d "$backup_dir" ]]; then
        echo "No backups found"
        return 0
    fi
    
    local backups=()
    for backup_file in "$backup_dir"/mode-switch-*.TODO.md; do
        if [[ -f "$backup_file" ]]; then
            local backup_name=$(basename "$backup_file" | sed 's/\.TODO\.md$//')
            backups+=("$backup_name")
        fi
    done
    
    if [[ ${#backups[@]} -eq 0 ]]; then
        echo "No mode switch backups found"
        return 0
    fi
    
    echo "Mode switch backups:"
    echo ""
    for backup in "${backups[@]}"; do
        local timestamp=$(echo "$backup" | sed 's/mode-switch-//')
        local date_str=$(echo "$timestamp" | sed 's/\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)/\1-\2-\3 \4:\5:\6/')
        echo "  $backup ($date_str)"
    done
}

# Get GitHub user ID (first 7 characters)
get_github_user_id() {
    local user_id=""
    
    # Try GitHub CLI first
    if command -v gh >/dev/null 2>&1; then
        user_id=$(gh api user --jq '.login' 2>/dev/null || echo "")
    fi
    
    # Fallback to Git config
    if [[ -z "$user_id" ]]; then
        # Try git config user.name
        local git_user=$(git config --get user.name 2>/dev/null || echo "")
        if [[ -n "$git_user" ]]; then
            # Convert to lowercase, remove non-alphanumeric, take first 7 chars
            user_id=$(echo "$git_user" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' | cut -c1-7)
        fi
    fi
    
    # Final fallback
    if [[ -z "$user_id" ]]; then
        # Use system username as last resort
        local sys_user=$(whoami 2>/dev/null || echo "user")
        user_id=$(echo "$sys_user" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]' | cut -c1-7)
    fi
    
    # Ensure we have something (at least 1 char)
    if [[ -z "$user_id" ]]; then
        user_id="user"
    fi
    
    # Take first 7 characters
    echo "${user_id:0:7}"
}

# Get current Git branch name (first 7 characters)
get_branch_name() {
    local branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
    
    if [[ -z "$branch" ]] || [[ "$branch" == "HEAD" ]]; then
        echo "main"  # Default branch name
        return 0
    fi
    
    # Take first 7 characters, remove non-alphanumeric
    branch=$(echo "$branch" | tr -cd '[:alnum:]_' | cut -c1-7)
    
    # Ensure we have something
    if [[ -z "$branch" ]]; then
        branch="main"
    fi
    
    echo "$branch"
}

# Assign task number based on current mode
assign_task_number() {
    local mode=$(get_numbering_mode)
    
    case "$mode" in
        "single-user")
            # Mode 1: Simple sequential numbering (with optional coordination)
            assign_task_number_single_user
            ;;
        "multi-user")
            # Mode 2: Prefix with GitHub user ID
            assign_task_number_multi_user
            ;;
        "branch")
            # Mode 3: Prefix with branch name
            assign_task_number_branch
            ;;
        "enhanced")
            # Mode 4: Enhanced coordination (GitHub Issues or CounterAPI)
            assign_task_number_enhanced
            ;;
        *)
            # Fallback to single-user
            increment_serial
            ;;
    esac
}

# Mode 1: Single-user numbering (with optional coordination)
assign_task_number_single_user() {
    # Check if coordination is configured for single-user mode
    local coord_type=$(get_config_value "coordination.type" "none")
    
    case "$coord_type" in
        "github-issues")
            assign_task_number_single_user_github_issues || increment_serial
            ;;
        "counterapi")
            assign_task_number_single_user_counterapi || increment_serial
            ;;
        *)
            # No coordination - use simple serial increment
            increment_serial
            ;;
    esac
}

# Single-user mode: GitHub Issues coordination (returns plain number)
assign_task_number_single_user_github_issues() {
    local issue_num=$(get_config_value "coordination.issue_number" "")
    local repo_url=$(git config --get remote.origin.url 2>/dev/null | sed 's/\.git$//' | sed 's/.*github\.com[:/]//' || echo "")
    
    if [[ -z "$issue_num" ]] || [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Get latest comment from issue
    local latest_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq 'sort_by(.created_at) | .[-1].body' 2>/dev/null || echo "")
    
    # Get coordinator value from issue comment
    local coordinator_value=0
    if [[ -n "$latest_comment" ]]; then
        # Extract number from comment (format: "Next task number: 123" or just "123")
        local extracted_num=$(echo "$latest_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -n "$extracted_num" ]] && [[ "$extracted_num" =~ ^[0-9]+$ ]]; then
            coordinator_value=$extracted_num
        fi
    fi
    
    # Get highest task number from TODO.md (checks both prefixed and non-prefixed tasks)
    local highest_task_num=$(get_highest_task_number)
    
    # Use max(coordinator_value, highest_task_num) + 1 to ensure no duplicates
    local max_value=$coordinator_value
    if [[ $highest_task_num -gt $max_value ]]; then
        max_value=$highest_task_num
    fi
    
    local new_num=$((max_value + 1))
    
    # If coordinator was behind, log a warning
    if [[ $coordinator_value -lt $highest_task_num ]]; then
        echo "‚ö†Ô∏è  Warning: Coordinator value ($coordinator_value) was behind TODO.md highest ($highest_task_num)" >&2
        echo "   Using max value: $max_value, next task: $new_num" >&2
    fi
    
    # Append new number as comment (with retry on conflicts)
    local max_retries=3
    local retry=0
    while [[ $retry -lt $max_retries ]]; do
        # Create comment with new number
        if gh api -X POST repos/${repo_url}/issues/${issue_num}/comments --field "body=Next task number: $new_num" >/dev/null 2>&1; then
            # Return plain number (no prefix)
            echo "$new_num"
            return 0
        fi
        
        # Check if number changed (concurrent update) - get latest comment by sorting
        local updated_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq 'sort_by(.created_at) | .[-1].body' 2>/dev/null || echo "")
        local updated_num=$(echo "$updated_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -n "$updated_num" ]] && [[ "$updated_num" != "$coordinator_value" ]]; then
            # Number changed, retry with new number
            coordinator_value=$updated_num
            max_value=$coordinator_value
            if [[ $highest_task_num -gt $max_value ]]; then
                max_value=$highest_task_num
            fi
            new_num=$((max_value + 1))
            retry=$((retry + 1))
        else
            # Unknown error, fallback
            return 1
        fi
    done
    
    # Max retries reached, fallback
    return 1
}

# Single-user mode: CounterAPI coordination (returns plain number)
assign_task_number_single_user_counterapi() {
    local namespace=$(get_config_value "coordination.namespace" "")
    local counter_name="task-counter"
    
    if [[ -z "$namespace" ]] || ! command -v curl >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Increment atomically via CounterAPI
    local response=$(curl -s -X POST "https://api.counterapi.dev/v1/${namespace}/${counter_name}/up" 2>/dev/null || echo "")
    
    if [[ -z "$response" ]]; then
        return 1  # Trigger fallback
    fi
    
    # Parse response (expect JSON with "value" field)
    local new_num=""
    if command -v jq >/dev/null 2>&1; then
        new_num=$(echo "$response" | jq -r '.value' 2>/dev/null || echo "")
    elif command -v python3 >/dev/null 2>&1; then
        new_num=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('value', ''))" 2>/dev/null || echo "")
    fi
    
    if [[ -z "$new_num" ]] || ! [[ "$new_num" =~ ^[0-9]+$ ]]; then
        return 1  # Trigger fallback
    fi
    
    # Check against TODO.md highest number and use max if needed
    local highest_task_num=$(get_highest_task_number)
    if [[ $highest_task_num -gt $new_num ]]; then
        # CounterAPI value is behind - we need to increment beyond the highest
        # Note: CounterAPI already incremented, so we use its value
        # But we should sync it by using max
        echo "‚ö†Ô∏è  Warning: CounterAPI value ($new_num) was behind TODO.md highest ($highest_task_num)" >&2
        # Use the higher value to ensure no duplicates
        if [[ $highest_task_num -ge $new_num ]]; then
            new_num=$((highest_task_num + 1))
            # Note: CounterAPI has already incremented, so we're using a value ahead
            # In practice, this is fine since CounterAPI ensures atomicity for concurrent requests
        fi
    fi
    
    # Return plain number (no prefix)
    echo "$new_num"
    return 0
}

# Mode 2: Multi-user numbering (user-prefix)
assign_task_number_multi_user() {
    local user_prefix=$(get_github_user_id)
    local todo_file="$TODO_FILE"
    
    # Find highest task number for this user prefix
    local highest=0
    
    # Construct pattern variable for zsh regex compatibility
    local pattern="\\*\\*#${user_prefix}-([0-9]+)\\*\\*"
    
    while IFS= read -r line; do
        # Match task IDs like fxstein-50 in TODO.md
        # Use pattern variable for zsh compatibility
        if [[ "$line" =~ $pattern ]]; then
            local num="${match[1]}"
            if [[ $num -gt $highest ]]; then
                highest=$num
            fi
        fi
    done < "$todo_file"
    
    local next_num=$((highest + 1))
    echo "${user_prefix}-${next_num}"
}

# Mode 3: Branch numbering (branch-prefix)
assign_task_number_branch() {
    local branch_prefix=$(get_branch_name)
    local todo_file="$TODO_FILE"
    
    # Find highest task number for this branch prefix
    local highest=0
    
    # Construct pattern variable for zsh regex compatibility
    local pattern="\\*\\*#${branch_prefix}-([0-9]+)\\*\\*"
    
    while IFS= read -r line; do
        # Match task IDs like feature-50 in TODO.md
        # Use pattern variable for zsh compatibility
        if [[ "$line" =~ $pattern ]]; then
            local num="${match[1]}"
            if [[ $num -gt $highest ]]; then
                highest=$num
            fi
        fi
    done < "$todo_file"
    
    local next_num=$((highest + 1))
    echo "${branch_prefix}-${next_num}"
}

# Mode 4: Enhanced multi-user numbering (with coordination)
assign_task_number_enhanced() {
    local coord_type=$(get_config_value "coordination.type" "none")
    local fallback_mode=$(get_config_value "coordination.fallback" "multi-user")
    
    case "$coord_type" in
        "github-issues")
            assign_task_number_enhanced_github_issues || assign_task_number_enhanced_fallback "$fallback_mode"
            ;;
        "counterapi")
            assign_task_number_enhanced_counterapi || assign_task_number_enhanced_fallback "$fallback_mode"
            ;;
        *)
            # No coordination configured, use fallback
            assign_task_number_enhanced_fallback "$fallback_mode"
            ;;
    esac
}

# Enhanced mode: GitHub Issues coordination
assign_task_number_enhanced_github_issues() {
    local issue_num=$(get_config_value "coordination.issue_number" "")
    local repo_url=$(git config --get remote.origin.url 2>/dev/null | sed 's/\.git$//' | sed 's/.*github\.com[:/]//' || echo "")
    
    if [[ -z "$issue_num" ]] || [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Get latest comment from issue (comments are returned in chronological order, so get last one)
    # Sort by created_at to ensure we get the newest comment, or use last element if already sorted
    local latest_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq 'sort_by(.created_at) | .[-1].body' 2>/dev/null || echo "")
    
    # Get coordinator value from issue comment
    local coordinator_value=0
    if [[ -n "$latest_comment" ]]; then
        # Extract number from comment (format: "Next task number: 123" or just "123")
        local extracted_num=$(echo "$latest_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -n "$extracted_num" ]] && [[ "$extracted_num" =~ ^[0-9]+$ ]]; then
            coordinator_value=$extracted_num
        fi
    fi
    
    # Get highest task number from TODO.md (checks both prefixed and non-prefixed tasks)
    local highest_task_num=$(get_highest_task_number)
    
    # Use max(coordinator_value, highest_task_num) + 1 to ensure no duplicates
    local max_value=$coordinator_value
    if [[ $highest_task_num -gt $max_value ]]; then
        max_value=$highest_task_num
    fi
    
    local new_num=$((max_value + 1))
    
    # If coordinator was behind, log a warning
    if [[ $coordinator_value -lt $highest_task_num ]]; then
        echo "‚ö†Ô∏è  Warning: Coordinator value ($coordinator_value) was behind TODO.md highest ($highest_task_num)" >&2
        echo "   Using max value: $max_value, next task: $new_num" >&2
    fi
    
    # Append new number as comment (with retry on conflicts)
    local max_retries=3
    local retry=0
    while [[ $retry -lt $max_retries ]]; do
        # Create comment with new number
        if gh api -X POST repos/${repo_url}/issues/${issue_num}/comments --field "body=Next task number: $new_num" >/dev/null 2>&1; then
            # Get user prefix for formatting
            local user_prefix=$(get_github_user_id)
            echo "${user_prefix}-${new_num}"
            return 0
        fi
        
        # Check if number changed (concurrent update) - get latest comment by sorting
        local updated_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq 'sort_by(.created_at) | .[-1].body' 2>/dev/null || echo "")
        local updated_num=$(echo "$updated_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -n "$updated_num" ]] && [[ "$updated_num" != "$current_num" ]]; then
            # Number changed, retry with new number
            current_num=$updated_num
            new_num=$((current_num + 1))
            retry=$((retry + 1))
        else
            # Unknown error, fallback
            return 1
        fi
    done
    
    # Max retries reached, fallback
    return 1
}

# Enhanced mode: CounterAPI coordination
assign_task_number_enhanced_counterapi() {
    local namespace=$(get_config_value "coordination.namespace" "")
    local counter_name="task-counter"
    
    if [[ -z "$namespace" ]] || ! command -v curl >/dev/null 2>&1; then
        return 1  # Trigger fallback
    fi
    
    # Increment atomically via CounterAPI
    local response=$(curl -s -X POST "https://api.counterapi.dev/v1/${namespace}/${counter_name}/up" 2>/dev/null || echo "")
    
    if [[ -z "$response" ]]; then
        return 1  # Trigger fallback
    fi
    
    # Parse response (expect JSON with "value" field)
    local new_num=""
    if command -v jq >/dev/null 2>&1; then
        new_num=$(echo "$response" | jq -r '.value' 2>/dev/null || echo "")
    elif command -v python3 >/dev/null 2>&1; then
        new_num=$(echo "$response" | python3 -c "import sys, json; print(json.load(sys.stdin).get('value', ''))" 2>/dev/null || echo "")
    fi
    
    if [[ -z "$new_num" ]] || ! [[ "$new_num" =~ ^[0-9]+$ ]]; then
        return 1  # Trigger fallback
    fi
    
    # Get user prefix for formatting
    local user_prefix=$(get_github_user_id)
    echo "${user_prefix}-${new_num}"
    return 0
}

# Enhanced mode: Fallback to simpler mode
assign_task_number_enhanced_fallback() {
    local fallback_mode="$1"
    
    case "$fallback_mode" in
        "multi-user")
            assign_task_number_multi_user
            ;;
        "branch")
            assign_task_number_branch
            ;;
        *)
            # Default to single-user
            increment_serial
            ;;
    esac
}

# Resolve task reference (auto-add prefix for number-only references)
resolve_task_reference() {
    local input="$1"
    local mode=$(get_numbering_mode)
    
    # If already has prefix (format: prefix-number), use as-is
    if [[ "$input" =~ ^[a-z0-9]{1,7}-[0-9]+$ ]]; then
        echo "$input"
        return 0
    fi
    
    # If just a number, add prefix based on mode
    if [[ "$input" =~ ^[0-9]+$ ]]; then
        case "$mode" in
            "multi-user"|"enhanced")
                local user_prefix=$(get_github_user_id)
                echo "${user_prefix}-${input}"
                return 0
                ;;
            "branch")
                local branch_prefix=$(get_branch_name)
                echo "${branch_prefix}-${input}"
                return 0
                ;;
            "single-user")
                # No prefix needed for single-user
                echo "$input"
                return 0
                ;;
        esac
    fi
    
    # Invalid format
    echo "ERROR: Invalid task ID format: $input" >&2
    return 1
}

# Extract numeric part from task ID (removes prefix if present)
extract_task_number() {
    local task_id="$1"
    
    # If has prefix (format: prefix-number), extract number
    if [[ "$task_id" =~ ^[a-z0-9]{1,7}-([0-9]+)$ ]]; then
        echo "${match[1]}"
        return 0
    fi
    
    # If has subtask format (prefix-number.subtask), extract both parts
    if [[ "$task_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)$ ]]; then
        echo "${match[1]}.${match[2]}"
        return 0
    fi
    
    # If just number or number.subtask, return as-is
    if [[ "$task_id" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
        echo "$task_id"
        return 0
    fi
    
    # Invalid format
    return 1
}

# Generate new task ID based on mode and numeric part
generate_new_task_id() {
    local numeric_part="$1"
    local mode="$2"
    
    # Extract parent and subtask numbers if present
    local parent_num=""
    local subtask_num=""
    if [[ "$numeric_part" =~ ^([0-9]+)\.([0-9]+)$ ]]; then
        parent_num="${match[1]}"
        subtask_num="${match[2]}"
    elif [[ "$numeric_part" =~ ^([0-9]+)$ ]]; then
        parent_num="${match[1]}"
    else
        return 1
    fi
    
    # Generate prefix based on mode
    local prefix=""
    case "$mode" in
        "multi-user"|"enhanced")
            prefix=$(get_github_user_id)
            ;;
        "branch")
            prefix=$(get_branch_name)
            ;;
        "single-user")
            prefix=""  # No prefix
            ;;
        *)
            return 1
            ;;
    esac
    
    # Build new ID
    if [[ -z "$prefix" ]]; then
        # Single-user: no prefix
        if [[ -n "$subtask_num" ]]; then
            echo "${parent_num}.${subtask_num}"
        else
            echo "${parent_num}"
        fi
    else
        # Multi-user/branch: with prefix
        if [[ -n "$subtask_num" ]]; then
            echo "${prefix}-${parent_num}.${subtask_num}"
        else
            echo "${prefix}-${parent_num}"
        fi
    fi
}

# Renumber tasks when switching modes
renumber_tasks_for_mode() {
    local old_mode="$1"
    local new_mode="$2"
    
    if [[ ! -f "$TODO_FILE" ]]; then
        return 1
    fi
    
    # Build ID mapping: old_id -> new_id
    declare -A id_mapping
    
    # Collect all task IDs from TODO.md
    local temp_file=$(mktemp)
    local tasks_found=0
    
    # Find all task IDs in TODO.md (handle both prefixed and non-prefixed formats)
    while IFS= read -r line; do
        # Match task IDs in format: **#task_id** or **#prefix-task_id**
        # Handle both main tasks and subtasks
        if [[ "$line" =~ \*\*#([0-9a-z.\-]+)\*\* ]]; then
            local full_task_id="${match[1]}"  # BASH_CONVERT: BASH_REMATCH[1]
            
            # Extract numeric part (removes prefix if present)
            local numeric_part=$(extract_task_number "$full_task_id" 2>/dev/null)
            if [[ -z "$numeric_part" ]]; then
                continue
            fi
            
            # Generate new ID based on new mode
            local new_id=$(generate_new_task_id "$numeric_part" "$new_mode" 2>/dev/null)
            if [[ -z "$new_id" ]]; then
                continue
            fi
            
            # Add to mapping if IDs differ
            if [[ "$full_task_id" != "$new_id" ]]; then
                id_mapping["$full_task_id"]="$new_id"
                tasks_found=$((tasks_found + 1))
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $tasks_found -eq 0 ]]; then
        rm -f "$temp_file"
        return 0  # No tasks to renumber
    fi
    
    # Create new TODO.md with renumbered tasks
    local new_file=$(mktemp)
    local renumbered_count=0
    
    while IFS= read -r line || [[ -n "$line" ]]; do
        local new_line="$line"
        local line_changed=false
        
        # Skip empty lines
        if [[ -z "$new_line" ]]; then
            echo "" >> "$new_file"
            continue
        fi
        
        # Replace task IDs in task lines (**#task_id**)
        for old_id in "${!id_mapping[@]}"; do
            local new_id="${id_mapping[$old_id]}"
            
            # Escape old_id for sed (escape special regex characters)
            local escaped_old_id=$(echo "$old_id" | sed 's/[[\.*^$()+?{|]/\\&/g')
            
            # Replace in task definition: **#old_id**
            if echo "$new_line" | grep -q "\*\*#${escaped_old_id}\*\*"; then
                new_line=$(echo "$new_line" | sed "s/\*\*#${escaped_old_id}\*\*/\*\*#${new_id}\*\*/g")
                line_changed=true
            fi
            
            # Replace in relationships and notes (plain text references)
            # Match: #old_id (standalone or in lists)
            if echo "$new_line" | grep -q "#${escaped_old_id}\([^0-9a-z-]\|$\)"; then
                new_line=$(echo "$new_line" | sed "s/#${escaped_old_id}\([^0-9a-z-]\|$\)/#${new_id}\1/g")
                line_changed=true
            fi
            
            # Replace in relationship comments (HTML comments)
            if echo "$new_line" | grep -q "${escaped_old_id}:"; then
                new_line=$(echo "$new_line" | sed "s/${escaped_old_id}:/${new_id}:/g")
                line_changed=true
            fi
        done
        
        if [[ "$line_changed" == true ]]; then
            renumbered_count=$((renumbered_count + 1))
        fi
        
        echo "$new_line" >> "$new_file"
    done < "$TODO_FILE"
    
    # Replace original file
    mv "$new_file" "$TODO_FILE"
    rm -f "$temp_file"
    
    if [[ $renumbered_count -gt 0 ]]; then
        update_footer
        return 0
    else
        return 1
    fi
}

# Switch numbering mode
switch_mode() {
    local new_mode="$1"
    local force=false
    local renumber=false
    local original_args=("$@")
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f)
                force=true
                shift
                ;;
            --renumber)
                renumber=true
                shift
                ;;
            *)
                if [[ -z "$new_mode" ]]; then
                    new_mode="$1"
                fi
                shift
                ;;
        esac
    done
    
    if [[ -z "$new_mode" ]]; then
        echo "Error: Please specify a mode to switch to"
        echo "Usage: ./todo.ai switch-mode <mode> [--force] [--renumber]"
        echo "Modes: single-user, multi-user, branch, enhanced"
        echo "Options:"
        echo "  --force      Force mode switch (skip validation)"
        echo "  --renumber   Renumber existing tasks to match new mode"
        return 1
    fi
    
    # Validate mode
    case "$new_mode" in
        "single-user"|"multi-user"|"branch"|"enhanced")
            ;;
        *)
            echo "Error: Invalid mode '$new_mode'"
            echo "Valid modes: single-user, multi-user, branch, enhanced"
            return 1
            ;;
    esac
    
    # Get current mode
    local current_mode=$(get_numbering_mode)
    
    # Check if already in requested mode
    if [[ "$current_mode" == "$new_mode" ]]; then
        echo "Already in mode: $new_mode"
        return 0
    fi
    
    # Create backup before switching
    echo "Creating backup before mode switch..."
    local backup_name=$(create_mode_backup)
    if [[ -z "$backup_name" ]]; then
        echo "Error: Failed to create backup. Aborting mode switch."
        return 1
    fi
    echo "‚úÖ Backup created: $backup_name"
    echo ""
    
    # Validate configuration for new mode
    local config_file=$(get_config_file)
    local config_dir=$(dirname "$config_file")
    
    # Ensure config directory exists
    mkdir -p "$config_dir" 2>/dev/null || return 1
    
    # Update or create config file
    if [[ -f "$config_file" ]]; then
        # Update existing config file
        # Try yq first
        if command -v yq >/dev/null 2>&1; then
            yq eval ".mode = \"$new_mode\"" -i "$config_file" 2>/dev/null || {
                # Fallback to Python (with yaml module)
                if command -v python3 >/dev/null 2>&1 && python3 -c "import yaml" 2>/dev/null; then
                    python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f) or {}
    config['mode'] = '$new_mode'
    with open('$config_file', 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
except Exception as e:
    sys.exit(1)
EOF
                    if [[ $? -ne 0 ]]; then
                        echo "Error: Failed to update config file"
                        return 1
                    fi
                else
                    # Fallback to sed (simple mode update)
                    sed_inplace "s/^mode:.*/mode: $new_mode/" "$config_file" || {
                        # If mode line doesn't exist, add it
                        if ! grep -q "^mode:" "$config_file"; then
                            echo "mode: $new_mode" >> "$config_file"
                        else
                            echo "Error: Failed to update config file"
                            return 1
                        fi
                    }
                fi
            }
        else
            # Fallback to Python or sed
            if command -v python3 >/dev/null 2>&1 && python3 -c "import yaml" 2>/dev/null; then
                python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f) or {}
    config['mode'] = '$new_mode'
    with open('$config_file', 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
except Exception as e:
    sys.exit(1)
EOF
                if [[ $? -ne 0 ]]; then
                    echo "Error: Failed to update config file"
                    return 1
                fi
            else
                # Fallback to sed (simple mode update)
                sed_inplace "s/^mode:.*/mode: $new_mode/" "$config_file" || {
                    if ! grep -q "^mode:" "$config_file"; then
                        echo "mode: $new_mode" >> "$config_file"
                    else
                        echo "Error: Failed to update config file"
                        return 1
                    fi
                }
            fi
        fi
    else
        # Create new config file
        cat > "$config_file" <<EOF
# todo.ai Configuration File
# This file configures the task numbering system for this repository

# Mode: single-user | multi-user | branch | enhanced
mode: $new_mode

# Coordination settings (for enhanced mode)
coordination:
  type: none
  fallback: multi-user

# Conflict resolution settings
conflict_resolution:
  enabled: true
  auto_resolve: true
  renumber_on_conflict: true
  notify_on_conflict: false

# Display settings
display:
  show_prefix: false
  user_reference_style: number-only
EOF
    fi
    
    # Validate new configuration
    if ! validate_config; then
        echo "Error: Invalid configuration after mode switch"
        echo "Attempting to restore from backup..."
        rollback_from_backup "$backup_name" >/dev/null 2>&1 || true
        return 1
    fi
    
    # Optionally renumber tasks
    if [[ "$renumber" == true ]]; then
        echo ""
        echo "üîÑ Renumbering tasks to match new mode..."
        if ! renumber_tasks_for_mode "$current_mode" "$new_mode"; then
            echo "‚ö†Ô∏è  Warning: Task renumbering encountered issues"
            echo "   Some tasks may not have been renumbered correctly"
            echo "   Backup available: $backup_name"
        else
            echo "‚úÖ Tasks renumbered successfully"
        fi
        echo ""
    fi
    
    # Log the action
    log_todo_action "MODE_SWITCH" "$current_mode ‚Üí $new_mode" "Switched from $current_mode to $new_mode"
    
    echo "‚úÖ Mode switched: $current_mode ‚Üí $new_mode"
    echo ""
    if [[ "$renumber" == false ]]; then
        echo "üìù Note: Existing tasks keep their current IDs"
        echo "   New tasks will use the $new_mode numbering scheme"
        echo "   Use --renumber flag to renumber existing tasks"
    else
        echo "üìù All tasks have been renumbered to match $new_mode numbering scheme"
    fi
    echo ""
    echo "üíæ Backup saved as: $backup_name"
    echo "   To rollback: ./todo.ai rollback-mode $backup_name"
    
    return 0
}

# Function to get next serial number
increment_serial() {
    # Ensure .todo.ai directory exists
    local serial_dir=$(dirname "$SERIAL_FILE")
    if [[ ! -d "$serial_dir" ]]; then
        mkdir -p "$serial_dir" 2>/dev/null || return 1
    fi
    
    # Get current value from serial file
    local serial_value=0
    if [[ -f "$SERIAL_FILE" ]]; then
        serial_value=$(cat "$SERIAL_FILE")
    fi
    
    # Get highest ID from TODO.md (handles actual tasks, ignoring examples in notes)
    local todo_highest=$(get_highest_task_number)
    
    # Use the maximum of serial file and TODO.md, then increment
    local max_id=$serial_value
    if [[ $todo_highest -gt $max_id ]]; then
        max_id=$todo_highest
    fi
    
    local next=$((max_id + 1))
    echo "$next" > "$SERIAL_FILE"
    echo "$next"
}

# Function to update the Last Updated date in the footer
update_footer() {
    local current_date=$(date)
    # Update the Last Updated line in the footer
    sed_inplace "s/\*\*Last Updated:\*\* .*/\*\*Last Updated:\*\* $current_date/" "$TODO_FILE"
}

# Function to log TODO operations
log_todo_action() {
    # Ensure .todo.ai directory exists
    local log_dir=$(dirname "$LOG_FILE")
    if [[ ! -d "$log_dir" ]]; then
        mkdir -p "$log_dir" 2>/dev/null || return 1
    fi
    
    local action="$1"
    local task_id="$2"
    local description="$3"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local git_user=$(git config --get user.name 2>/dev/null || echo "unknown")
    
    # Create log entry in format: TIMESTAMP | USER | ACTION | TASK_ID | DESCRIPTION
    local log_entry="$timestamp | $git_user | $action | $task_id | $description"
    
    # Create temporary file with header preserved at top, then new entry, then existing entries
    local temp_file=$(mktemp)
    
    # Extract header lines (lines starting with #)
    grep "^#" "$LOG_FILE" > "$temp_file" || true
    echo "" >> "$temp_file"
    
    # Add new entry
    echo "$log_entry" >> "$temp_file"
    
    # Add existing log entries (skip header lines)
    grep -v "^#" "$LOG_FILE" | grep -v "^$" >> "$temp_file" || true
    
    mv "$temp_file" "$LOG_FILE"
}

# Function to initialize log file if it doesn't exist
init_log_file() {
    # Ensure .todo.ai directory exists
    local log_dir=$(dirname "$LOG_FILE")
    if [[ ! -d "$log_dir" ]]; then
        mkdir -p "$log_dir" 2>/dev/null || return 1
    fi
    
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "# TODO Tool Log File" > "$LOG_FILE"
        echo "# Format: TIMESTAMP | USER | ACTION | TASK_ID | DESCRIPTION" >> "$LOG_FILE"
        echo "# Generated: $(date)" >> "$LOG_FILE"
        echo "" >> "$LOG_FILE"
    fi
}

# Function to initialize TODO file if it doesn't exist
init_todo_file() {
    if [[ ! -f "$TODO_FILE" ]]; then
        # Detect repository name and URL from git
        local repo_name="Project"
        local repo_url=""
        
        # Try to get repository name from git remote
        if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
            local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
            if [[ -n "$remote_url" ]]; then
                # Extract repository name from URL (handle both https:// and git@ formats)
                if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                    repo_name="${match[2]}"
                    # Remove .git suffix if present
                    repo_name="${repo_name%.git}"
                    # Convert to title case (first letter uppercase)
                    repo_name="$(echo "${repo_name:0:1}" | tr '[:lower:]' '[:upper:]')${repo_name:1}"
                    # Clean up URL (remove .git suffix if present, ensure https://)
                    repo_url="${remote_url%.git}"
                    if [[ ! "$repo_url" =~ ^https:// ]]; then
                        # Convert git@ format to https://
                        repo_url=$(echo "$repo_url" | sed 's/git@github\.com:/https:\/\/github.com\//')
                    fi
                fi
            fi
        fi
        
        cat > "$TODO_FILE" << EOF
# ${repo_name} ToDo List

> **‚ö†Ô∏è IMPORTANT: This file should ONLY be edited through the \`todo.ai\` script!**

## Tasks

------------------

## Recently Completed

---

**Last Updated:** $(date)
EOF
        # Add repository URL if detected
        if [[ -n "$repo_url" ]]; then
            echo "**Repository:** ${repo_url}  " >> "$TODO_FILE"
        fi
        echo "**Maintenance:** Use \`todo.ai\` script only" >> "$TODO_FILE"
        
        # Replace the $(date) placeholder with actual date
        local current_date=$(date)
        sed_inplace "s/\$(date)/$current_date/" "$TODO_FILE"
    fi
}

# Function to ensure Cursor rules include todo.ai requirement
init_cursor_rules() {
    local rules_dir="$(pwd)/.cursor/rules"
    local cursor_rules_file="$(pwd)/.cursorrules"
    local rules_created=0
    local rules_updated=0
    
    # Detect installation path for dynamic substitution in rules
    local todo_ai_path=$(get_todo_ai_path_for_rules)
    
    # If .cursorrules exists but .cursor/rules/ doesn't, let migration handle it
    if [[ -f "$cursor_rules_file" ]] && [[ ! -d "$rules_dir" ]]; then
        # Migration will handle the conversion, we just need to ensure rules directory exists
        mkdir -p "$rules_dir" 2>/dev/null || return 1
        return 0
    fi
    
    # Create .cursor/rules/ directory if it doesn't exist
    mkdir -p "$rules_dir" 2>/dev/null || return 1
    
    # Define end-user rule files (shipped with tool)
    local task_mgmt_file="${rules_dir}/todo.ai-task-management.mdc"
    local installation_file="${rules_dir}/todo.ai-installation.mdc"
    local bug_reporting_file="${rules_dir}/todo.ai-bug-reporting.mdc"
    local uninstall_file="${rules_dir}/todo.ai-uninstall.mdc"
    local commit_format_file="${rules_dir}/todo.ai-commit-format.mdc"
    local task_notes_file="${rules_dir}/todo.ai-task-notes.mdc"
    
    # Task Management rule content
    local task_mgmt_content="It is required to track tasks and subtasks using todo.ai and not via built in TODO tools
TODO.md and .todo.ai/ must always be committed together
Always ask for user confirmation before archiving completed tasks using todo.ai"
    
    # Installation rule content (with detected path)
    local installation_content="When installing todo.ai from https://github.com/fxstein/todo.ai, use curl to download the single file: \`curl -o todo.ai https://raw.githubusercontent.com/fxstein/todo.ai/main/todo.ai && chmod +x todo.ai\`. Do NOT clone the repository with git clone - only the single todo.ai file is needed.

To update an existing installation, run: \`$todo_ai_path update\`"
    
    # Bug Reporting rule content (with detected path)
    local bug_reporting_content="When todo.ai encounters errors or unexpected behavior, or when the user asks to report a bug:

**CRITICAL REQUIREMENTS:**
1. **MUST use \`$todo_ai_path report-bug\` command** - This is the ONLY way to report bugs about todo.ai
2. **NEVER use \`gh issue create\` directly** - This bypasses all safeguards and duplicate detection
3. **NEVER use GitHub API directly** for bug reports - Always go through the bug reporting feature
4. Always require explicit user confirmation before any GitHub API calls
5. Show preview of bug report before asking for confirmation
6. Respect privacy: For private repositories, remove all repo identifiers

**Usage:**
\`\`\`bash
$todo_ai_path report-bug \"Error description\" \"Error context\" \"command\"
\`\`\`

**Examples:**
- ‚úÖ User says \"report a bug about X\": Use \`$todo_ai_path report-bug \"X\" \"context\" \"command\"\`
- ‚úÖ \"An error occurred. Would you like me to report this bug?\" ‚Üí If yes, use \`$todo_ai_path report-bug\`
- ‚ùå \"Error occurred. Automatically reporting to GitHub...\" (NEVER DO THIS)
- ‚ùå Using \`gh issue create\` directly for bug reports (NEVER DO THIS)
- ‚ùå Creating GitHub issues manually with \`gh CLI\` for todo.ai bugs (NEVER DO THIS)

**Why this is required:**
- The bug reporting feature includes duplicate detection
- It ensures proper formatting and context collection
- It maintains user control and privacy protection
- It follows the designed workflow for bug tracking"
    
    # Uninstall rule content (with detected path)
    local uninstall_content="When uninstalling todo.ai, or when the user asks to remove or delete todo.ai:

**CRITICAL REQUIREMENTS:**
1. **MUST use \`$todo_ai_path uninstall\` command** - This is the ONLY way to uninstall todo.ai
2. **NEVER delete files directly** - Do NOT use \`rm\`, \`rmdir\`, or file deletion commands on:
   - The todo.ai script file
   - The .todo.ai/ data directory
   - The .cursor/rules/todo.ai-*.mdc rule files
3. **NEVER use file system operations directly** - Always go through the uninstall feature
4. Always require explicit user confirmation before any uninstall operations
5. Show preview of what will be removed before asking for confirmation
6. Control uninstall scope: The uninstall command provides options to control what gets removed

**Usage:**
\`\`\`bash
$todo_ai_path uninstall                  # Remove script only (preserves data and rules)
$todo_ai_path uninstall --remove-data   # Remove script and data directory
$todo_ai_path uninstall --remove-rules  # Remove script and Cursor rules
$todo_ai_path uninstall --all           # Remove everything (script + data + rules)
\`\`\`

**Examples:**
- ‚úÖ User says \"uninstall todo.ai\": Use \`$todo_ai_path uninstall\`
- ‚úÖ User says \"remove todo.ai and data\": Use \`$todo_ai_path uninstall --remove-data\`
- ‚úÖ User says \"delete todo.ai completely\": Use \`$todo_ai_path uninstall --all\`
- ‚ùå \"Removing todo.ai files...\" and using \`rm todo.ai\` (NEVER DO THIS)
- ‚ùå Using \`rm -rf .todo.ai\` directly (NEVER DO THIS)
- ‚ùå Deleting .cursor/rules/todo.ai-*.mdc files manually (NEVER DO THIS)

**Why this is required:**
- The uninstall feature ensures safe removal with proper scope control
- It prevents accidental deletion of user data
- It provides clear preview and confirmation before removal
- It maintains proper cleanup of all todo.ai components
- It preserves TODO.md files (never removed by uninstall)"
    
    # Commit Format rule content
    local commit_format_content="When referencing todo.ai task numbers in commit messages:

**CRITICAL REQUIREMENTS:**
1. **MUST use \`task#nn\` format** (e.g., \`task#15\`, \`task#50\`) when referencing todo.ai task numbers
2. **NEVER use \`#nn\` format** for task numbers - this causes GitHub to auto-link to issues/PRs
3. Always use the \`task#\` prefix before task numbers to prevent GitHub auto-linking

**Format Examples:**
- ‚úÖ Correct: \`feat: Implement git hooks with pre-commit validation (task#15)\`
- ‚úÖ Correct: \`Archive completed task#15 (git hooks), delete task#21\`
- ‚úÖ Correct: \`feat: Add automated linter setup script (task#15.8, task#15.9)\`
- ‚ùå Incorrect: \`feat: Implement git hooks (#15)\` - will auto-link to issue #15
- ‚ùå Incorrect: \`feat: Implement git hooks (task #15)\` - space breaks pattern

**Why this is required:**
- GitHub automatically links \`#number\` patterns to issues and pull requests
- Task numbers like \`#15\` conflict with GitHub issue numbers
- Using \`task#15\` prevents auto-linking and eliminates confusion
- Keeps commit history clear and accurate"
    
    # Task Notes rule content (with detected path)
    local task_notes_content="When creating or working with todo.ai tasks, add notes to provide implementation context. Do not use notes for status updates on parent tasks.

**Command:** \`$todo_ai_path note <task-id> \"Your note here\"\`

**Examples:**
- ‚úÖ \`$todo_ai_path note 42 \"Modify archive_task() lines 2600-2850. Pattern from delete_task() lines 2926-2935\"\`
- ‚úÖ \`$todo_ai_path note 42.1 \"Depends on task#42 completing first - needs collect_notes() function\"\`
- ‚úÖ \`$todo_ai_path note 50 \"See docs/CODE_SIZE_ANALYSIS.md lines 66-67 for migration cleanup details\"\`
- ‚ùå \`$todo_ai_path note 42 \"Fix it\"\` - Too vague, no actionable context

Notes appear as blockquotes (>) and move with tasks when archived."
    
    # Create or update Task Management rule
    if [[ ! -f "$task_mgmt_file" ]]; then
        cat > "$task_mgmt_file" << EOF
---
description: "Task management rules for todo.ai"
alwaysApply: true
---
$task_mgmt_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "track tasks" "$task_mgmt_file" || ! grep -q "committed together" "$task_mgmt_file" || ! grep -q "archiving completed tasks" "$task_mgmt_file"; then
            # Update existing file
            cat > "$task_mgmt_file" << EOF
---
description: "Task management rules for todo.ai"
alwaysApply: true
---
$task_mgmt_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Installation rule
    if [[ ! -f "$installation_file" ]]; then
        cat > "$installation_file" << EOF
---
description: "Installation instructions for todo.ai"
alwaysApply: true
---
$installation_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date
        if ! grep -q "curl -o todo.ai" "$installation_file"; then
            # Update existing file
            cat > "$installation_file" << EOF
---
description: "Installation instructions for todo.ai"
alwaysApply: true
---
$installation_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Bug Reporting rule
    if [[ ! -f "$bug_reporting_file" ]]; then
        cat > "$bug_reporting_file" << EOF
---
description: "Bug reporting rules for todo.ai"
alwaysApply: true
---
$bug_reporting_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "CRITICAL REQUIREMENTS" "$bug_reporting_file" || ! grep -q "MUST use.*report-bug" "$bug_reporting_file" || ! grep -q "NEVER use.*gh issue create" "$bug_reporting_file"; then
            # Update existing file
            cat > "$bug_reporting_file" << EOF
---
description: "Bug reporting rules for todo.ai"
alwaysApply: true
---
$bug_reporting_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Uninstall rule
    if [[ ! -f "$uninstall_file" ]]; then
        cat > "$uninstall_file" << EOF
---
description: "Uninstall rules for todo.ai"
alwaysApply: true
---
$uninstall_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "CRITICAL REQUIREMENTS" "$uninstall_file" || ! grep -q "MUST use.*uninstall" "$uninstall_file" || ! grep -q "NEVER delete files directly" "$uninstall_file"; then
            # Update existing file
            cat > "$uninstall_file" << EOF
---
description: "Uninstall rules for todo.ai"
alwaysApply: true
---
$uninstall_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Commit Format rule
    if [[ ! -f "$commit_format_file" ]]; then
        cat > "$commit_format_file" << EOF
---
description: "Commit message format rules for todo.ai task references"
alwaysApply: true
---
$commit_format_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "CRITICAL REQUIREMENTS" "$commit_format_file" || ! grep -q "MUST use.*task#" "$commit_format_file" || ! grep -q "NEVER use.*#nn" "$commit_format_file"; then
            # Update existing file
            cat > "$commit_format_file" << EOF
---
description: "Commit message format rules for todo.ai task references"
alwaysApply: true
---
$commit_format_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Create or update Task Notes rule
    if [[ ! -f "$task_notes_file" ]]; then
        cat > "$task_notes_file" << EOF
---
description: "Guidelines for using notes with todo.ai tasks"
alwaysApply: true
---
$task_notes_content
EOF
        rules_created=$((rules_created + 1))
    else
        # Check if rule is up to date (contains key indicators)
        if ! grep -q "add notes to provide implementation context" "$task_notes_file" || ! grep -q "note <task-id>" "$task_notes_file"; then
            # Update existing file
            cat > "$task_notes_file" << EOF
---
description: "Guidelines for using notes with todo.ai tasks"
alwaysApply: true
---
$task_notes_content
EOF
            rules_updated=$((rules_updated + 1))
        fi
    fi
    
    # Show feedback if rules were created or updated
    if [[ $rules_created -gt 0 ]] || [[ $rules_updated -gt 0 ]]; then
        echo ""
        echo "‚ö†Ô∏è  IMPORTANT: Cursor rules initialized"
        if [[ $rules_created -gt 0 ]]; then
            echo "   üìù Created $rules_created rule file(s) in .cursor/rules/"
        fi
        if [[ $rules_updated -gt 0 ]]; then
            echo "   üìù Updated $rules_updated rule file(s) in .cursor/rules/"
        fi
        echo "   This ensures AI agents will automatically use todo.ai for task tracking"
        echo ""
        echo "   üîÑ ACTION REQUIRED: Cursor rules have been initialized!"
        echo ""
        echo "   For Humans:"
        echo "   ‚Üí Please start a new chat session in Cursor"
        echo "   ‚Üí Cursor only loads rules at the start of each chat session"
        echo "   ‚Üí The rules will not apply to your current session"
        echo ""
        echo "   For AI Agents:"
        echo "   ‚Üí Inform the user that cursor rules have been initialized"
        echo "   ‚Üí Request that the user start a new chat session"
        echo "   ‚Üí The rules will only take effect in a new session"
    fi
    
    return 0
}

# Function to get current serial number
get_current_serial() {
    if [[ -f "$SERIAL_FILE" ]]; then
        cat "$SERIAL_FILE"
    else
        echo "0"
    fi
}

# Function to parse task line and extract components
parse_task() {
    local line="$1"
    local id=$(echo "$line" | grep -o '^#\([0-9.]*\)' | sed 's/#//')
    local description=$(echo "$line" | sed 's/^#[0-9.]* *//' | sed 's/ *#.*$//')
    local tags=$(echo "$line" | grep -o '#[a-zA-Z0-9]*' | grep -v '^#[0-9]' | tr '\n' ' ')
    local date=$(echo "$line" | grep -o '([^)]*)' | tr -d '()')
    
    echo "ID:$id|DESC:$description|TAGS:$tags|DATE:$date"
}

# Function to normalize malformed checkboxes
normalize_checkboxes() {
    # Fix malformed checkboxes like [  ], [   ], [] to proper [ ] or [x]
    sed_inplace 's/\[  \]/[ ]/g' "$TODO_FILE"
    sed_inplace 's/\[   \]/[ ]/g' "$TODO_FILE"
    sed_inplace 's/\[    \]/[ ]/g' "$TODO_FILE"
    sed_inplace 's/\[\]/[ ]/g' "$TODO_FILE"
    # Fix any other malformed patterns with multiple spaces
    sed_inplace 's/\[[ ]*\]/[ ]/g' "$TODO_FILE"
}

# Function to show usage
show_usage() {
    echo "Usage: ./todo.ai [command] [options]"
    echo ""
    echo "Version: $VERSION"
    echo ""
    echo "Commands:"
    echo "  add <text> [tags]             Add a new todo item with optional tags"
    echo "  add-subtask <parent-id> <text> [tags]  Add a subtask to an existing task (supports 2-level nesting)"
    echo "  list [--tag <tag>] [--incomplete-only] [--parents-only] [--has-subtasks]  Show todo list with filters"
    echo "  complete <id> [<id>...] [--with-subtasks]  Mark item(s) as completed"
    echo "  undo <id>                     Reopen (undo) completed task (use #ID)"
    echo "  modify <id> <text> [tags]     Modify task description and/or tags"
    echo "  delete <id> [<id>...] [--with-subtasks]  Soft delete task(s) to Deleted section (30-day recovery)"
    echo "  archive <id> [<id>...] [--reason <reason>]  Move task(s) to Recently Completed (reason for incomplete tasks)"
    echo "  relate <id> --<type> <targets>  Add task relationship (completed-by, depends-on, blocks, related-to, duplicate-of)"
    echo "  note <id> <text>              Add note to task (blockquote format)"
    echo "  delete-note <id>              Delete all notes from a task"
    echo "  update-note <id> <text>       Replace existing notes with new text"
    echo "  show <id>                     Show task with subtasks, relationships, and notes"
    echo "  restore <id>                  Restore task from Deleted or Recently Completed to active Tasks"
    echo "  --lint                        Identify formatting issues (indentation, checkboxes)"
    echo "  --reformat [--dry-run]        Apply formatting fixes (use --dry-run to preview)"
    echo "  resolve-conflicts [--dry-run] Detect and resolve duplicate task IDs (optional dry-run)"
    echo "  edit                          Edit todo file in editor"
    echo "  log [--filter <text>] [--lines <n>] View TODO operation log"
    echo "  update                        Update todo.ai to latest version"
    echo "  backups, list-backups         List available backup versions"
    echo "  rollback [index|timestamp]    Rollback to previous version (default: latest backup)"
    echo "  report-bug \"description\"      Report a bug to GitHub Issues (requires GitHub CLI)"
    echo "  uninstall [--remove-data] [--remove-rules] [--all]  Uninstall todo.ai"
    echo "  switch-mode <mode> [--force] [--renumber]  Switch numbering mode (single-user, multi-user, branch, enhanced)"
    echo "  list-mode-backups             List mode switch backups"
    echo "  rollback-mode <backup-name>   Rollback from mode switch backup"
    echo "  config, show-config           Show current configuration"
    echo "  detect-coordination           Detect available coordination options based on system"
    echo "  setup-coordination <type>     Set up coordination service (github-issues, counterapi)"
    echo "  setup, setup-wizard           Interactive setup wizard for mode and coordination"
    echo "  version, -v, --version        Show version information"
    echo ""
    echo ""
    echo "Examples:"
    echo "  ./todo.ai add 'Fix Shelly device naming' '#api'"
    echo "  ./todo.ai add-subtask 39 'Design subtask data structure' '#feature'"
    echo "  ./todo.ai add-subtask 39.1 'Create nested subtask' '#test'    # 2-level nesting"
    echo "  ./todo.ai complete 1"
    echo "  ./todo.ai complete 107 108 109          # Bulk complete"
    echo "  ./todo.ai complete 104 --with-subtasks  # Complete task and all subtasks"
    echo "  ./todo.ai complete 104.3-104.10         # Complete range of subtasks"
    echo "  ./todo.ai undo 1"
    echo "  ./todo.ai modify 1 'Updated task description' '#api'"
    echo "  ./todo.ai delete 115                    # Soft delete (30-day recovery)"
    echo "  ./todo.ai delete 110 --with-subtasks    # Delete task and all subtasks"
    echo "  ./todo.ai delete 120.5-120.10           # Delete range"
    echo "  ./todo.ai archive 1"
    echo "  ./todo.ai archive 107 108 109           # Bulk archive"
    echo "  ./todo.ai archive 109 --reason obsolete # Archive incomplete task"
    echo "  ./todo.ai archive 104 --reason 'completed-by:107,108'"
    echo "  ./todo.ai relate 110 --depends-on 104  # Add dependency"
    echo "  ./todo.ai relate 104 --completed-by '107,108'"
    echo "  ./todo.ai note 110 'Testing shows issues'  # Add note"
    echo "  ./todo.ai delete-note 110             # Delete all notes from task #110"
    echo "  ./todo.ai update-note 110 'Updated information'  # Replace notes"
    echo "  ./todo.ai show 110                    # Show task with relationships & notes"
    echo "  ./todo.ai restore 1"
    echo "  ./todo.ai --lint"
    echo "  ./todo.ai --reformat --dry-run"
    echo "  ./todo.ai --reformat"
    echo "  ./todo.ai resolve-conflicts --dry-run  # Preview conflict resolution"
    echo "  ./todo.ai resolve-conflicts            # Resolve duplicate task IDs"
    echo "  ./todo.ai list"
    echo "  ./todo.ai list --tag api"
    echo "  ./todo.ai list --incomplete-only     # Show only pending tasks"
    echo "  ./todo.ai list --parents-only        # Hide subtasks"
    echo "  ./todo.ai list --has-subtasks        # Only tasks with subtasks"
    echo "  ./todo.ai log"
    echo "  ./todo.ai log --filter ADD"
    echo "  ./todo.ai log --lines 20"
    echo "  ./todo.ai update                     # Update to latest version"
    echo "  ./todo.ai backups                    # List available backups"
    echo "  ./todo.ai rollback                   # Rollback to latest backup"
    echo "  ./todo.ai rollback 2                 # Rollback to backup #2"
    echo "  ./todo.ai rollback 20251030231500     # Rollback by timestamp"
    echo "  ./todo.ai report-bug \"Error message\" # Report bug to GitHub Issues"
    echo "  ./todo.ai uninstall                  # Uninstall script only"
    echo "  ./todo.ai uninstall --all             # Uninstall script, data, and rules"
    echo "  ./todo.ai switch-mode multi-user     # Switch to multi-user numbering mode"
    echo "  ./todo.ai switch-mode multi-user --renumber  # Switch and renumber existing tasks"
    echo "  ./todo.ai switch-mode branch          # Switch to branch-based numbering"
    echo "  ./todo.ai list-mode-backups           # List mode switch backups"
    echo "  ./todo.ai rollback-mode <backup-name> # Rollback from mode switch"
    echo "  ./todo.ai config                      # Show current configuration"
    echo "  ./todo.ai detect-coordination         # Check available coordination options"
    echo "  ./todo.ai setup-coordination github-issues  # Set up GitHub Issues coordination"
    echo "  ./todo.ai setup-coordination counterapi     # Set up CounterAPI coordination"
    echo "  ./todo.ai setup                       # Run interactive setup wizard"
    echo "  ./todo.ai version                    # Show version"
    echo ""
    echo "Copyright 2025 Oliver Ratzesberger"
    echo "Licensed under the Apache License, Version 2.0"
    echo "Repository: $REPO_URL"
}

# Function to validate command arguments and detect invalid options
validate_command_args() {
    local command="$1"
    shift
    local args=("$@")
    
    case "$command" in
        "add")
            # add <text> [tags] - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'add' command"
                    echo "The 'add' command only accepts text and optional tags"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "add-subtask")
            # add-subtask <parent-id> <text> [tags] - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'add-subtask' command"
                    echo "The 'add-subtask' command only accepts parent-id, text, and optional tags"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "list")
            # list [--tag <tag>] [--incomplete-only] [--parents-only] [--has-subtasks]
            local expecting_tag=false
            for arg in "${args[@]}"; do
                if [[ "$arg" == "--tag" ]]; then
                    expecting_tag=true
                elif [[ "$arg" =~ ^--(incomplete-only|parents-only|has-subtasks)$ ]]; then
                    # Valid flags
                    continue
                elif [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'list' command"
                    echo "The 'list' command accepts: --tag <tag>, --incomplete-only, --parents-only, --has-subtasks"
                    echo ""
                    show_usage
                    return 1
                elif [[ "$expecting_tag" == true ]]; then
                    expecting_tag=false
                fi
            done
            ;;
        "complete")
            # complete <id> [<id>...] [--with-subtasks] - allow multiple IDs and --with-subtasks flag
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]] && [[ "$arg" != "--with-subtasks" ]]; then
                    echo "Error: Invalid option '$arg' for 'complete' command"
                    echo "The 'complete' command accepts task ID(s) and optional --with-subtasks flag"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "undo")
            # undo <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'undo' command"
                    echo "The 'undo' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "modify")
            # modify <id> <text> [tags] - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'modify' command"
                    echo "The 'modify' command only accepts task-id, text, and optional tags"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "archive")
            # archive <id> [<id>...] [--reason <reason>] - allow multiple IDs and reason
            local expecting_reason=false
            for arg in "${args[@]}"; do
                if [[ "$arg" == "--reason" ]]; then
                    expecting_reason=true
                elif [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'archive' command"
                    echo "The 'archive' command accepts task ID(s) and optional --reason <reason>"
                    echo ""
                    show_usage
                    return 1
                elif [[ "$expecting_reason" == true ]]; then
                    expecting_reason=false
                fi
            done
            ;;
        "delete")
            # delete <id> [<id>...] [--with-subtasks] - allow multiple IDs and --with-subtasks
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]] && [[ "$arg" != "--with-subtasks" ]]; then
                    echo "Error: Invalid option '$arg' for 'delete' command"
                    echo "The 'delete' command accepts task ID(s) and optional --with-subtasks flag"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "relate")
            # relate <id> --<relation-type> <targets> - relationship management
            # Allow all --completed-by, --depends-on, --blocks, --related-to, --duplicate-of
            ;;
        "note")
            # note <id> <text> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'note' command"
                    echo "The 'note' command only accepts task ID and note text"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "delete-note")
            # delete-note <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'delete-note' command"
                    echo "The 'delete-note' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "update-note")
            # update-note <id> <text> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'update-note' command"
                    echo "The 'update-note' command only accepts task ID and note text"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "show")
            # show <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'show' command"
                    echo "The 'show' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "restore")
            # restore <id> - no additional options allowed
            for arg in "${args[@]}"; do
                if [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'restore' command"
                    echo "The 'restore' command only accepts a task ID"
                    echo ""
                    show_usage
                    return 1
                fi
            done
            ;;
        "log")
            # log [--filter <text>] [--lines <n>] - only --filter and --lines allowed
            local expecting_filter=false
            local expecting_lines=false
            for arg in "${args[@]}"; do
                if [[ "$arg" == "--filter" ]]; then
                    expecting_filter=true
                elif [[ "$arg" == "--lines" ]]; then
                    expecting_lines=true
                elif [[ "$arg" =~ ^-- ]]; then
                    echo "Error: Invalid option '$arg' for 'log' command"
                    echo "The 'log' command only accepts --filter <text> and --lines <n> options"
                    echo ""
                    show_usage
                    return 1
                elif [[ "$expecting_filter" == true ]]; then
                    expecting_filter=false
                elif [[ "$expecting_lines" == true ]]; then
                    expecting_lines=false
                fi
            done
            ;;
    esac
    
    return 0
}

# Function to add todo item
add_todo() {
    local text="$1"
    local tags="$2"
    
    if [[ -z "$text" ]]; then
        echo "Error: Please provide todo text"
        return 1
    fi
    
    # Validate configuration before proceeding
    if ! validate_config; then
        echo "‚ö†Ô∏è  Configuration error detected. Using default mode (single-user)." >&2
    fi
    
    # Get next task number based on current mode
    local task_id=$(assign_task_number)
    
    # Format the task line with bold task ID
    local task_line="- [ ] **#$task_id** $text"
    if [[ -n "$tags" ]]; then
        # Wrap each tag in backticks for code styling
        local styled_tags=""
        # Split tags by space and process each one
        for tag in $(echo "$tags" | tr ' ' '\n'); do
            if [[ -n "$styled_tags" ]]; then
                styled_tags="$styled_tags \`$tag\`"
            else
                styled_tags="\`$tag\`"
            fi
        done
        task_line="$task_line $styled_tags"
    fi
    
    # Add to Tasks section
    local tasks_line=$(grep -n "^## Tasks" "$TODO_FILE" | cut -d: -f1)
    if [[ -n "$tasks_line" ]]; then
        # Use awk or a simpler approach for macOS compatibility
        if [[ "$(uname)" == "Darwin" ]]; then
            # Insert after the ## Tasks line with proper newline
            local temp_file=$(mktemp)
            head -n "$tasks_line" "$TODO_FILE" > "$temp_file"
            echo "$task_line" >> "$temp_file"
            tail -n +$((tasks_line + 1)) "$TODO_FILE" >> "$temp_file"
            mv "$temp_file" "$TODO_FILE"
        else
            sed_inplace "/^## Tasks$/a$task_line" "$TODO_FILE"
        fi
    fi
    update_footer
    
    # Log the action
    log_todo_action "ADD" "$task_id" "$text"
    
    echo "Added: #$task_id $text"
}

# Function to calculate nesting depth from task ID
get_nesting_depth() {
    local task_id="$1"
    # Count the number of dots in the task ID
    local depth=$(echo "$task_id" | tr -cd '.' | wc -c | tr -d ' ')
    # Depth is number of dots (0 for main tasks like "1", 1 for "1.1", 2 for "1.1.1")
    echo "$depth"
}

# Function to add subtask to existing task (supports nested subtasks up to 2 levels)
add_subtask() {
    local parent_id="$1"
    local text="$2"
    local tags="$3"
    
    if [[ -z "$parent_id" || -z "$text" ]]; then
        echo "Error: Please provide parent task ID and subtask text"
        echo "Usage: ./todo.ai add-subtask <parent-id> \"<subtask text>\" [\"<tags>\"]"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local original_parent_id="$parent_id"
    local resolved_parent_id=$(resolve_task_reference "$parent_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_parent_id" ]]; then
        resolved_parent_id="$parent_id"
    fi
    
    # Check nesting depth of parent (use resolved ID for depth calculation)
    local parent_depth=$(get_nesting_depth "$resolved_parent_id")
    
    # Validate max nesting (2 levels: main task ‚Üí subtask ‚Üí sub-subtask)
    if [[ $parent_depth -ge 2 ]]; then
        echo "Error: Cannot add subtask to #$parent_id"
        echo "   Maximum nesting depth is 2 levels (main task ‚Üí subtask ‚Üí sub-subtask)"
        echo "   Task #$parent_id is already at the maximum depth"
        return 1
    fi
    
    # Check if parent task exists (can be main task or subtask)
    local parent_found=false
    local parent_line_num=""
    local parent_indent=""
    local final_parent_id=""  # Will be set to the actual ID found in TODO.md
    
    # Check for main task pattern: `^- \[.*\] \*\*#$resolved_parent_id\*\* `
    if grep -q "^- \[.*\] \*\*#$resolved_parent_id\*\* " "$TODO_FILE"; then
        parent_found=true
        parent_line_num=$(grep -n "^- \[.*\] \*\*#$resolved_parent_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
        parent_indent="  "  # Main tasks have subtasks indented with 2 spaces
        final_parent_id="$resolved_parent_id"
    # Check for subtask pattern: `^  - \[.*\] \*\*#$resolved_parent_id\*\* `
    elif grep -q "^  - \[.*\] \*\*#$resolved_parent_id\*\* " "$TODO_FILE"; then
        parent_found=true
        parent_line_num=$(grep -n "^  - \[.*\] \*\*#$resolved_parent_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
        parent_indent="    "  # Subtasks have sub-subtasks indented with 4 spaces
        final_parent_id="$resolved_parent_id"
    # Fallback: if resolved ID has a prefix but not found, try original plain number
    elif [[ "$resolved_parent_id" != "$original_parent_id" ]] && [[ "$resolved_parent_id" =~ ^[a-z0-9]{1,7}-([0-9]+(\.[0-9]+)?)$ ]]; then
        local plain_parent_id="${match[1]}"
        # Check for main task pattern with plain ID
        if grep -q "^- \[.*\] \*\*#${plain_parent_id}\*\* " "$TODO_FILE"; then
            parent_found=true
            parent_line_num=$(grep -n "^- \[.*\] \*\*#${plain_parent_id}\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
            parent_indent="  "
            final_parent_id="$plain_parent_id"  # Use plain ID for creating subtask ID
        # Check for subtask pattern with plain ID
        elif grep -q "^  - \[.*\] \*\*#${plain_parent_id}\*\* " "$TODO_FILE"; then
            parent_found=true
            parent_line_num=$(grep -n "^  - \[.*\] \*\*#${plain_parent_id}\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
            parent_indent="    "
            final_parent_id="$plain_parent_id"  # Use plain ID for creating subtask ID
        fi
    fi
    
    # Set parent_id to the final ID found (or resolved ID if not found with fallback)
    if [[ -z "$final_parent_id" ]]; then
        parent_id="$resolved_parent_id"
    else
        parent_id="$final_parent_id"
    fi
    
    if [[ "$parent_found" == false ]]; then
        echo "Error: Parent task #$parent_id not found"
        return 1
    fi
    
    # Find the next subtask number for this parent
    local next_subtask_num=1
    local subtask_pattern="^$parent_indent- \[.*\] \*\*#$parent_id\.$next_subtask_num\*\* "
    while grep -q "$subtask_pattern" "$TODO_FILE"; do
        next_subtask_num=$((next_subtask_num + 1))
        subtask_pattern="^$parent_indent- \[.*\] \*\*#$parent_id\.$next_subtask_num\*\* "
    done
    
    # Create subtask ID
    local subtask_id="$parent_id.$next_subtask_num"
    
    # Format the subtask line with bold task ID and proper indentation
    local task_line="$parent_indent- [ ] **#$subtask_id** $text"
    if [[ -n "$tags" ]]; then
        # Wrap each tag in backticks for code styling
        local styled_tags=""
        # Split tags by space and process each one
        for tag in $(echo "$tags" | tr ' ' '\n'); do
            if [[ -n "$styled_tags" ]]; then
                styled_tags="$styled_tags \`$tag\`"
            else
                styled_tags="\`$tag\`"
            fi
        done
        task_line="$task_line $styled_tags"
    fi
    
    # Find the parent task line and add subtask after it (newest first)
    if [[ -n "$parent_line_num" ]]; then
        # Insert right after the parent line AND any notes (newest subtasks appear first)
        # Skip over any blockquote notes following the parent task
        local insert_line=$((parent_line_num + 1))
        local check_line=$insert_line
        while true; do
            local line_content=$(sed -n "${check_line}p" "$TODO_FILE")
            # Check if line is a blockquote at the expected indentation level
            # Parent notes: "  > " (2 spaces), subtask notes: "    > " (4 spaces)
            local note_pattern="^${parent_indent}> "
            if [[ "$line_content" =~ $note_pattern ]]; then
                # This is a note for the parent, skip over it
                insert_line=$((check_line + 1))
                check_line=$((check_line + 1))
            else
                # Not a note, stop here
                break
            fi
        done
        
        local max_lines=$(wc -l < "$TODO_FILE" | tr -d ' ')
        
        if [[ "$(uname)" == "Darwin" ]]; then
            local temp_file=$(mktemp)
            if [[ $insert_line -gt $max_lines ]]; then
                # Append to end of file
                cat "$TODO_FILE" > "$temp_file"
                echo "$task_line" >> "$temp_file"
            else
                head -n $((insert_line - 1)) "$TODO_FILE" > "$temp_file"
                echo "$task_line" >> "$temp_file"
                tail -n +$insert_line "$TODO_FILE" >> "$temp_file"
            fi
            mv "$temp_file" "$TODO_FILE"
        else
            sed_inplace "${insert_line}i\\$task_line" "$TODO_FILE"
        fi
        update_footer
        
        # Log the action
        log_todo_action "ADD_SUBTASK" "$subtask_id" "$text (parent: #$parent_id)"
        
        local depth_label="subtask"
        if [[ $parent_depth -eq 1 ]]; then
            depth_label="sub-subtask"
        fi
        echo "Added $depth_label: #$subtask_id $text"
    else
        echo "Error: Could not find parent task #$parent_id"
        return 1
    fi
}

# Function to list todos
list_todos() {
    local filter_tag=""
    local incomplete_only=false
    local parents_only=false
    local has_subtasks_only=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --tag)
                filter_tag="$2"
                shift 2
                ;;
            --incomplete-only)
                incomplete_only=true
                shift
                ;;
            --parents-only)
                parents_only=true
                shift
                ;;
            --has-subtasks)
                has_subtasks_only=true
                shift
                ;;
            *)
                shift
                ;;
        esac
    done
    
    if [[ ! -f "$TODO_FILE" ]]; then
        echo "Todo file not found: $TODO_FILE"
        return 1
    fi
    
    # If using tag filter, use original implementation
    if [[ -n "$filter_tag" ]] && [[ "$incomplete_only" == false ]] && [[ "$parents_only" == false ]] && [[ "$has_subtasks_only" == false ]]; then
        # Add # prefix if missing
        if [[ ! "$filter_tag" =~ ^# ]]; then
            filter_tag="#$filter_tag"
        fi
        
        # Filter by tag - show tasks with the specified tag
        # Escape special characters in filter_tag for regex matching
        local escaped_tag=$(echo "$filter_tag" | sed 's/[.*+?^${}()|\[\]\\]/\\&/g')
        
        echo "# Home Assistant Project Todo List"
        echo ""
        echo "## Tasks with tag: $filter_tag"
        echo ""
        # Match tags both with backticks (styled) and without (plain)
        # Match all task levels: main tasks (0 spaces), subtasks (2 spaces), sub-subtasks (4 spaces)
        grep -E "\`${escaped_tag}\`|${escaped_tag}" "$TODO_FILE" | grep -E "^-.*\[.*\]|^  -.*\[.*\]|^    -.*\[.*\]"
        echo ""
        echo "## Recently Completed with tag: $filter_tag"
        echo ""
        grep -E "\`${escaped_tag}\`|${escaped_tag}" "$TODO_FILE" | grep -E "^-.*\[x\]|^  -.*\[x\]|^    -.*\[x\]"
        return
    fi
    
    # Enhanced filtering logic
    local in_tasks_section=false
    local in_recently_completed=false
    local current_parent=""
    local parent_has_subtasks=false
    local last_parent_shown=false
    
    # First pass: identify parents with subtasks if needed
    local parents_with_subtasks=()
    if [[ "$has_subtasks_only" == true ]]; then
        while IFS= read -r line; do
            # Check if this is a subtask (starts with "  - ")
            if [[ "$line" =~ ^"  - ".+#([0-9]+)\.([0-9]+) ]]; then
                local parent_id="${match[1]}"
                if [[ ! " ${parents_with_subtasks[@]} " =~ " ${parent_id} " ]]; then
                    parents_with_subtasks+=("$parent_id")
                fi
            fi
        done < "$TODO_FILE"
    fi
    
    # Second pass: filter and display
    while IFS= read -r line; do
        # Track sections
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks_section=true
            in_recently_completed=false
            if [[ "$incomplete_only" == false ]]; then
                echo "$line"
            fi
            continue
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks_section=false
            in_recently_completed=true
            if [[ "$incomplete_only" == false ]]; then
                echo "$line"
            fi
            continue
        elif [[ "$line" =~ ^## ]]; then
            # Other section, stop filtering
            if [[ "$incomplete_only" == false ]]; then
                echo "$line"
            fi
            in_tasks_section=false
            in_recently_completed=false
            continue
        fi
        
        # Skip completed section if --incomplete-only
        if [[ "$incomplete_only" == true ]] && [[ "$in_recently_completed" == true ]]; then
            continue
        fi
        
        # Check if this is a parent task (starts with "- [" and has **#num** but not **#num.num**)
        if [[ "$line" == "- ["*"**#"*"**"* ]] && [[ "$line" != *"**#"*"."*"**"* ]]; then
            # Extract task ID and checkbox
            local checkbox=$(echo "$line" | sed 's/^- \[\(.\)\].*/\1/')
            current_parent=$(echo "$line" | grep -o '#[0-9]\+' | sed 's/#//' | head -1)
            
            # Apply filters
            local should_show=true
            
            # Filter: incomplete only (skip completed tasks)
            if [[ "$incomplete_only" == true ]] && [[ "$checkbox" == "x" ]]; then
                should_show=false
            fi
            
            # Filter: has-subtasks only
            if [[ "$has_subtasks_only" == true ]]; then
                if [[ ! " ${parents_with_subtasks[@]} " =~ " ${current_parent} " ]]; then
                    should_show=false
                fi
            fi
            
            # Filter: tag (match both styled with backticks and plain)
            if [[ -n "$filter_tag" ]]; then
                if [[ ! "$filter_tag" =~ ^# ]]; then
                    filter_tag="#$filter_tag"
                fi
                # Check if line contains the tag (with or without backticks)
                if [[ ! "$line" =~ \`${filter_tag}\` ]] && [[ ! "$line" =~ ${filter_tag} ]]; then
                    should_show=false
                fi
            fi
            
            last_parent_shown=$should_show
            if [[ "$should_show" == true ]]; then
                echo "$line"
            fi
        # Check if this is a subtask (starts with "  - ")
        elif [[ "$line" =~ ^"  - " ]]; then
            # Show subtasks unless --parents-only, and only if parent was shown
            if [[ "$parents_only" == false ]] && [[ "$last_parent_shown" == true ]]; then
                # Apply same filters as parent
                local should_show=true
                
                # Tag filter (match both styled with backticks and plain)
                if [[ -n "$filter_tag" ]]; then
                    if [[ ! "$line" =~ \`${filter_tag}\` ]] && [[ ! "$line" =~ ${filter_tag} ]]; then
                        should_show=false
                    fi
                fi
                
                if [[ "$should_show" == true ]]; then
                    echo "$line"
                fi
            fi
        else
            # Non-task line (headers, footers, blank lines, etc.)
            # Only show if not heavily filtering
            if [[ "$incomplete_only" == false ]] && [[ "$parents_only" == false ]] && [[ "$has_subtasks_only" == false ]]; then
                echo "$line"
            elif [[ "$in_tasks_section" == true ]] || [[ "$line" == "" ]] || [[ "$line" =~ ^## ]]; then
                # Always show headers and blank lines in tasks section
                echo "$line"
            fi
        fi
    done < "$TODO_FILE"
}

# Function to get line number of task by serial number
get_task_line() {
    local task_id="$1"
    local line_number=0
    
    while IFS= read -r line; do
        line_number=$((line_number + 1))
        if [[ "$line" =~ "^-.*\[.*\].*" || "$line" =~ "^  -.*\[.*\].*" ]]; then
            # Extract the ID from the line (handle both bold and non-bold formatting, and subtasks)
            local line_id=$(echo "$line" | grep -o '\*\*#\([0-9][0-9.]*\)\*\*\|#[0-9][0-9.]*' | sed 's/\*\*#//g' | sed 's/\*\*//g' | sed 's/#//')
            if [[ "$line_id" == "$task_id" ]]; then
                echo "$line_number"
                return 0
            fi
        fi
    done < "$TODO_FILE"
    
    echo "Task #$task_id not found"
    return 1
}

# Function to mark as complete
complete_todo() {
    local with_subtasks=false
    local task_ids=()
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --with-subtasks)
                with_subtasks=true
                shift
                ;;
            *)
                task_ids+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#task_ids[@]} -eq 0 ]]; then
        echo "Error: Please provide at least one task number"
        return 1
    fi
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Resolve task references and expand ranges
    local all_ids=()
    for id in "${task_ids[@]}"; do
        # Resolve task reference (auto-add prefix for number-only references)
        local resolved_id=$(resolve_task_reference "$id" 2>/dev/null)
        if [[ $? -ne 0 ]] || [[ -z "$resolved_id" ]]; then
            # If resolution failed, try using original ID (might be a range or already have prefix)
            resolved_id="$id"
        fi
        
        # Match range format: 104.3-104.10 or 122.3-10 (both formats supported)
        if [[ "$resolved_id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)\.([0-9]+)$ ]] || [[ "$resolved_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)-[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)$ ]]; then
            # Full format: 122.3-122.10
            local parent=${match[1]}
            local start=${match[2]}
            local end_parent=${match[3]}
            local end=${match[4]}
            # Verify parent IDs match
            if [[ "$parent" == "$end_parent" ]]; then
                for ((i=start; i<=end; i++)); do
                    all_ids+=("${parent}.${i}")
                done
            else
                echo "Warning: Range parent IDs don't match ($parent vs $end_parent), treating as literal"
                all_ids+=("$id")
            fi
        elif [[ "$id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)$ ]]; then
            # Short format: 122.3-10 (assumes same parent)
            local parent=${match[1]}
            local start=${match[2]}
            local end=${match[3]}
            for ((i=start; i<=end; i++)); do
                all_ids+=("${parent}.${i}")
            done
        else
            all_ids+=("$id")
        fi
    done
    
    # If --with-subtasks, add all subtasks for parent tasks (including nested subtasks)
    if [[ "$with_subtasks" == "true" ]]; then
        local expanded_ids=()
        for id in "${all_ids[@]}"; do
            expanded_ids+=("$id")
            # Find all subtasks and sub-subtasks for this parent
            # Check if this is a parent task (may or may not contain dots)
            local id_depth=$(get_nesting_depth "$id")
            
            # Find all direct subtasks and nested subtasks
            # Pattern matches: id.1, id.2, id.1.1, id.1.2, id.2.1, etc.
            while IFS= read -r line; do
                # Extract task ID from line (handles nested IDs)
                if [[ "$line" =~ '#([0-9]+(\.[0-9]+)+)' ]]; then
                    local task_id="${match[1]}"
                    # Check if this task belongs to our parent (direct or nested subtask)
                    # For main task 1, match: 1.1, 1.2, 1.1.1, 1.1.2, etc.
                    # For subtask 1.1, match: 1.1.1, 1.1.2, etc.
                    if [[ "$task_id" =~ ^$id\. ]]; then
                        expanded_ids+=("$task_id")
                    fi
                fi
            done < "$TODO_FILE"
        done
        all_ids=("${expanded_ids[@]}")
    fi
    
    # Complete all tasks
    local completed_count=0
    for number in "${all_ids[@]}"; do
        # Skip if task doesn't exist (escape asterisks for grep)
        if ! grep -q "\*\*#$number\*\*" "$TODO_FILE"; then
            echo "Warning: Task #$number not found, skipping"
            continue
        fi
        
        # Complete the task
        sed_inplace "s/- \[ \] \*\*#$number\*\* /- [x] **#$number** /" "$TODO_FILE"
        sed_inplace "s/  - \[ \] \*\*#$number\*\* /  - [x] **#$number** /" "$TODO_FILE"
        
        # Get task description for logging
        local task_description=$(grep "\*\*#$number\*\*" "$TODO_FILE" | head -1 | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//')
        
        # Log the action
        log_todo_action "COMPLETE" "$number" "$task_description"
        
        completed_count=$((completed_count + 1))
    done
    
    update_footer
    
    echo "Marked $completed_count task(s) as completed"
}

# Function to undo completion (reopen task)
undo_todo() {
    local number="$1"
    if [[ -z "$number" ]]; then
        echo "Error: Please provide todo number"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_number=$(resolve_task_reference "$number" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_number" ]]; then
        resolved_number="$number"
    fi
    number="$resolved_number"
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Use sed to directly find and replace the specific task (handle bold formatting and subtasks)
    sed_inplace "s/- \[x\] \*\*#$number\*\* /- [ ] **#$number** /" "$TODO_FILE"
    sed_inplace "s/  - \[x\] \*\*#$number\*\* /  - [ ] **#$number** /" "$TODO_FILE"
    update_footer
    
    # Get task description for logging
    local task_description=$(grep "\*\*#$number\*\*" "$TODO_FILE" | head -1 | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//')
    
    # Log the action
    log_todo_action "UNDO" "$number" "$task_description"
    
    echo "Reopened task $number"
}

# Function to modify a specific task
modify_todo() {
    local task_id="$1"
    local new_text="$2"
    local new_tags="$3"
    
    if [[ -z "$task_id" || -z "$new_text" ]]; then
        echo "Error: Please provide task ID and new text"
        echo "Usage: ./todo.ai modify <id> \"<new text>\" [\"<new tags>\"]"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Get the current completion status and existing line (handle both bold and non-bold formatting, and subtasks)
    # Check all possible indentations: main tasks (0 spaces), subtasks (2 spaces), sub-subtasks (4 spaces)
    local current_line=$(grep -E "^- \[.*\] (\*\*#$task_id\*\*|#$task_id) |^  - \[.*\] (\*\*#$task_id\*\*|#$task_id) |^    - \[.*\] (\*\*#$task_id\*\*|#$task_id) " "$TODO_FILE" | head -1)
    local current_status=$(echo "$current_line" | sed 's/- \[\([^]]*\)\].*/\1/' | sed 's/  - \[\([^]]*\)\].*/\1/' | sed 's/    - \[\([^]]*\)\].*/\1/')
    
    # Extract existing tags from current line (tags are in backticks after the task text)
    local existing_tags=""
    if echo "$current_line" | grep -q '\`#'; then
        # Extract tags (everything in backticks)
        existing_tags=$(echo "$current_line" | sed 's/.*\(`#[^`]*`\).*/\1/' | sed 's/`//g')
        # Handle multiple tags
        local all_tags=$(echo "$current_line" | grep -o '\`#[^`]*`' | sed 's/`//g' | tr '\n' ' ' | sed 's/ $//')
        if [[ -n "$all_tags" ]]; then
            existing_tags="$all_tags"
        fi
    fi
    
    # Determine nesting depth to apply correct indentation
    local task_depth=$(get_nesting_depth "$task_id")
    local indent=""
    
    # Format the new task line preserving completion status with bold task ID
    # Apply indentation based on nesting depth:
    # Depth 0 (main task): no indentation
    # Depth 1 (subtask like #2.5): 2 spaces
    # Depth 2 (sub-subtask like #2.5.4): 4 spaces
    if [[ $task_depth -eq 0 ]]; then
        indent=""
    elif [[ $task_depth -eq 1 ]]; then
        indent="  "
    elif [[ $task_depth -eq 2 ]]; then
        indent="    "
    else
        # Fallback to 2 spaces if depth is unexpected
        indent="  "
    fi
    
    local new_task_line="${indent}- [$current_status] **#$task_id** $new_text"
    
    # Use new_tags if provided, otherwise preserve existing tags
    local tags_to_use=""
    if [[ -n "$new_tags" ]]; then
        tags_to_use="$new_tags"
    elif [[ -n "$existing_tags" ]]; then
        tags_to_use="$existing_tags"
    fi
    
    if [[ -n "$tags_to_use" ]]; then
        # Wrap each tag in backticks for code styling
        local styled_tags=""
        # Split tags by space and process each one
        for tag in $(echo "$tags_to_use" | tr ' ' '\n'); do
            if [[ -n "$styled_tags" ]]; then
                styled_tags="$styled_tags \`$tag\`"
            else
                styled_tags="\`$tag\`"
            fi
        done
        new_task_line="$new_task_line $styled_tags"
    fi
    
    # Replace the task line using sed (handle bold formatting and subtasks)
    # The pattern needs to match the entire line including any existing tags (with backticks)
    # Escape special characters for sed replacement (using pipe as delimiter)
    local escaped_line=$(printf '%s\n' "$new_task_line" | sed 's/\\/\\\\/g' | sed 's/&/\\&/g' | sed 's/|/\\|/g')
    
    # Use pipe delimiter to avoid conflicts with / and other characters in replacement
    # Escape dots in task_id for sed pattern matching (dots are regex metacharacters)
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    
    # Match everything after task ID including text and tags (with backticks)
    # Use task depth to determine which pattern to match (handles all indentation levels)
    if [[ $task_depth -eq 0 ]]; then
        # For main tasks, replace without indentation
        # Pattern matches: checkbox, task ID (with escaped dots), then everything (text and tags)
        sed_inplace "s|^- \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    elif [[ $task_depth -eq 1 ]]; then
        # For subtasks, replace with proper 2-space indentation
        # Pattern matches: checkbox, task ID (with escaped dots), then everything (text and tags)
        sed_inplace "s|^  - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    elif [[ $task_depth -eq 2 ]]; then
        # For sub-subtasks, replace with proper 4-space indentation
        # Pattern matches: checkbox, task ID (with escaped dots), then everything (text and tags)
        sed_inplace "s|^    - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    else
        # Fallback: try all indentation levels
        sed_inplace "s|^    - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE" || \
        sed_inplace "s|^  - \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE" || \
        sed_inplace "s|^- \[.*\] \*\*#$escaped_task_id\*\* .*|$escaped_line|" "$TODO_FILE"
    fi
    update_footer
    
    # Log the action
    log_todo_action "MODIFY" "$task_id" "$new_text"
    
    echo "Modified task #$task_id"
}

# Function to archive a completed task and its subtasks
# Helper function to collect notes (blockquotes) for a task
# Returns notes as a newline-separated string
collect_task_notes() {
    local task_id="$1"
    local notes=()
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    
    # Find the task line number (support arbitrary nesting depth)
    local task_line_num=$(grep -n "^[ ]*- \[.*\] \*\*#${escaped_task_id}\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    if [[ -n "$task_line_num" ]]; then
        # Collect blockquote notes following the task
        local current_line=$((task_line_num + 1))
        while true; do
            local line=$(sed -n "${current_line}p" "$TODO_FILE")
            # Check for blockquotes at any indentation level
            if [[ "$line" =~ ^[[:space:]]*\>  ]]; then
                notes+=("$line")
                current_line=$((current_line + 1))
            else
                break
            fi
        done
    fi
    
    # Return notes as newline-separated string
    if [[ ${#notes[@]} -gt 0 ]]; then
        printf '%s\n' "${notes[@]}"
    fi
}

# Helper function to remove notes (blockquotes) for a task
# This removes the task line AND its notes (used in delete operations)
remove_task_notes() {
    local task_id="$1"
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    
    # Find the task line number (support arbitrary nesting depth)
    local task_line_num=$(grep -n "^[ ]*- \[.*\] \*\*#${escaped_task_id}\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    if [[ -n "$task_line_num" ]]; then
        # Remove the task line first
        sed_inplace "${task_line_num}d" "$TODO_FILE"
        
        # Remove following blockquote notes (line number doesn't change after deletion)
        while true; do
            local next_line=$(sed -n "${task_line_num}p" "$TODO_FILE")
            # Check for blockquotes at any indentation level
            if [[ "$next_line" =~ ^[[:space:]]*\>  ]]; then
                sed_inplace "${task_line_num}d" "$TODO_FILE"
            else
                break
            fi
        done
    fi
}

# Helper function to delete ONLY notes from a task (keeps the task line)
delete_notes_only() {
    local task_id="$1"
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    
    # Find the task line number (support arbitrary nesting depth)
    local task_line_num=$(grep -n "^[ ]*- \[.*\] \*\*#${escaped_task_id}\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    if [[ -z "$task_line_num" ]]; then
        return 1  # Task not found
    fi
    
    # Count and remove following blockquote notes
    local note_count=0
    local next_line_num=$((task_line_num + 1))
    
    while true; do
        local next_line=$(sed -n "${next_line_num}p" "$TODO_FILE")
        # Check for blockquotes at any indentation level
        if [[ "$next_line" =~ ^[[:space:]]*\>  ]]; then
            # Delete this note line (line number stays same after each deletion)
            sed_inplace "${next_line_num}d" "$TODO_FILE"
            note_count=$((note_count + 1))
        else
            break
        fi
    done
    
    return 0
}

archive_task() {
    local task_id=""
    local reason=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --reason)
                reason="$2"
                shift 2
                ;;
            *)
                task_id="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai archive <id> [--reason <reason>]"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Determine task status and checkbox style
    local checkbox=""
    local status_note=""
    local is_completed=false
    
    # Check if task exists and its current state
    if grep -q "^- \[x\] \*\*#$task_id\*\* " "$TODO_FILE"; then
        # Task is completed
        is_completed=true
        checkbox="x"
    elif grep -q "^- \[ \] \*\*#$task_id\*\* " "$TODO_FILE"; then
        # Task is incomplete - need reason to archive
        if [[ -z "$reason" ]]; then
            echo "Error: Task #$task_id is not completed"
            echo "To archive incomplete tasks, provide --reason: obsolete, duplicate, wontfix, or completed-by:<tasks>"
            return 1
        fi
        # Set checkbox based on reason
        case "$reason" in
            obsolete)
                checkbox="~"
                status_note=" (obsolete)"
                ;;
            duplicate|duplicate:*)
                checkbox="~"
                status_note=" (duplicate)"
                ;;
            wontfix)
                checkbox="-"
                status_note=" (wontfix)"
                ;;
            completed-by:*)
                checkbox=">"
                status_note=" (${reason})"
                ;;
            *)
                checkbox="~"
                status_note=" (${reason})"
                ;;
        esac
    else
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    # Simple implementation: move the task to Recently Completed section
    # Get the task line (either completed or incomplete)
    # Escape task_id for grep pattern (escape dots and asterisks)
    local escaped_task_id=$(echo "$task_id" | sed 's/\./\\./g')
    local task_line=$(grep "^- \[[x ]\] \*\*#${escaped_task_id}\*\* " "$TODO_FILE")
    if [[ -z "$task_line" ]]; then
        echo "Error: Could not find task #$task_id"
        return 1
    fi
    
    # Update checkbox in task line if needed (for incomplete tasks with reason)
    if [[ "$checkbox" != "x" ]]; then
        # Replace checkbox: [ ] or [x] ‚Üí [$checkbox]
        task_line=$(echo "$task_line" | sed "s/\[.\]/[$checkbox]/")
    fi
    
    # Add completion date if not already present
    local archive_date=$(date +"%Y-%m-%d")
    if [[ ! "$task_line" =~ "\([0-9]{4}-[0-9]{2}-[0-9]{2}\)" ]]; then
        task_line="$task_line${status_note} ($archive_date)"
    fi
    
    # Collect notes for the main task
    local main_task_notes=$(collect_task_notes "$task_id")
    
    # Collect all subtasks and nested subtasks (completed or not) WITH their notes
    local subtasks_with_notes=()
    # Escape task_id for regex matching (escape dots)
    local escaped_task_id_regex=$(echo "$task_id" | sed 's/\./\\./g')
    while IFS= read -r line; do
        # Match subtasks at any nesting level: #task_id.1, #task_id.1.1, etc.
        # Use grep pattern instead of regex to avoid issues with asterisks
        if echo "$line" | grep -q "\*\*#${escaped_task_id_regex}\."; then
            # Extract subtask ID from the line
            local subtask_id=$(echo "$line" | grep -o "#${escaped_task_id_regex}\.[0-9.]*" | sed 's/^#//')
            
            # Add completion date if not already present
            if [[ ! "$line" =~ "\([0-9]{4}-[0-9]{2}-[0-9]{2}\)" ]]; then
                line="$line ($archive_date)"
            fi
            subtasks_with_notes+=("$line")
            
            # Collect notes for this subtask
            local subtask_notes=$(collect_task_notes "$subtask_id")
            if [[ -n "$subtask_notes" ]]; then
                # Add each note line to the array
                while IFS= read -r note_line; do
                    subtasks_with_notes+=("$note_line")
                done <<< "$subtask_notes"
            fi
        fi
    done < "$TODO_FILE"
    
    # Remove from Tasks section (main task and all subtasks at any nesting level) WITH notes
    # Use the helper function to remove task and its notes
    remove_task_notes "$task_id"
    
    # Remove subtasks (2 spaces) and sub-subtasks (4 spaces) WITH their notes
    # Need to collect all subtask IDs first to avoid line number issues
    local subtask_ids=()
    while IFS= read -r line; do
        if echo "$line" | grep -q "\*\*#${escaped_task_id_regex}\."; then
            local subtask_id=$(echo "$line" | grep -o "#${escaped_task_id_regex}\.[0-9.]*" | sed 's/^#//')
            subtask_ids+=("$subtask_id")
        fi
    done < "$TODO_FILE"
    
    # Remove each subtask with its notes
    for subtask_id in "${subtask_ids[@]}"; do
        remove_task_notes "$subtask_id"
    done
    
    # Create a complete block with main task, its notes, subtasks, and their notes
    local complete_block="$task_line"
    if [[ -n "$main_task_notes" ]]; then
        complete_block="$complete_block
$main_task_notes"
    fi
    
    if [[ ${#subtasks_with_notes[@]} -gt 0 ]]; then
        # Join subtasks and their notes with newlines
        local subtasks_text=$(printf '%s\n' "${subtasks_with_notes[@]}")
        complete_block="$complete_block
$subtasks_text"
    fi
    
    # Add to Recently Completed section
    local recently_completed_section=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1)
    if [[ -n "$recently_completed_section" ]]; then
        # Insert the complete block after the "## Recently Completed" line
        local temp_file=$(mktemp)
        echo -e "$complete_block" > "$temp_file"
        sed_inplace "${recently_completed_section}r $temp_file" "$TODO_FILE"
        rm -f "$temp_file"
    else
        # Add Recently Completed section if it doesn't exist
        echo "" >> "$TODO_FILE"
        echo "------------------" >> "$TODO_FILE"
        echo "" >> "$TODO_FILE"
        echo "## Recently Completed" >> "$TODO_FILE"
        echo -e "$complete_block" >> "$TODO_FILE"
    fi
    
    # Count subtasks for reporting
    local subtask_count=${#subtask_ids[@]}
    update_footer
    
    # Get task description for logging
    local task_description=$(echo "$task_line" | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//' | sed 's/ *([^)]*)$//')
    
    # Log the action
    log_todo_action "ARCHIVE" "$task_id" "$task_description (with $subtask_count subtasks)"
    
    echo "Archived task #$task_id and $subtask_count subtasks to Recently Completed section"
}

# Function to soft delete a task (move to Deleted section)
delete_task() {
    local with_subtasks=false
    local task_ids=()
    
    # Parse arguments (same pattern as complete)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --with-subtasks)
                with_subtasks=true
                shift
                ;;
            *)
                task_ids+=("$1")
                shift
                ;;
        esac
    done
    
    if [[ ${#task_ids[@]} -eq 0 ]]; then
        echo "Error: Please provide at least one task number"
        return 1
    fi
    
    # Normalize any malformed checkboxes first
    normalize_checkboxes
    
    # Auto-purge expired deleted tasks first
    purge_expired_deleted_tasks
    
    # Resolve task references and expand ranges
    local all_ids=()
    for id in "${task_ids[@]}"; do
        # Resolve task reference (auto-add prefix for number-only references)
        local resolved_id=$(resolve_task_reference "$id" 2>/dev/null)
        if [[ $? -ne 0 ]] || [[ -z "$resolved_id" ]]; then
            resolved_id="$id"
        fi
        
        if [[ "$resolved_id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)\.([0-9]+)$ ]] || [[ "$resolved_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)-[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)$ ]]; then
            local parent=${match[1]}
            local start=${match[2]}
            local end_parent=${match[3]}
            local end=${match[4]}
            if [[ "$parent" == "$end_parent" ]]; then
                for ((i=start; i<=end; i++)); do
                    all_ids+=("${parent}.${i}")
                done
            else
                all_ids+=("$id")
            fi
        elif [[ "$resolved_id" =~ ^([0-9]+)\.([0-9]+)-([0-9]+)$ ]] || [[ "$resolved_id" =~ ^[a-z0-9]{1,7}-([0-9]+)\.([0-9]+)-([0-9]+)$ ]]; then
            local parent=${match[1]}
            local start=${match[2]}
            local end=${match[3]}
            # Get prefix if present
            local prefix=""
            if [[ "$resolved_id" =~ ^([a-z0-9]{1,7})- ]]; then
                prefix="${match[1]}-"
            fi
            for ((i=start; i<=end; i++)); do
                all_ids+=("${prefix}${parent}.${i}")
            done
        else
            all_ids+=("$resolved_id")
        fi
    done
    
    # Automatically include subtasks when deleting parent tasks (tasks without dots)
    # This prevents orphaned subtasks when a parent is deleted
        local expanded_ids=()
        for id in "${all_ids[@]}"; do
            expanded_ids+=("$id")
        # If this is a parent task (no dots), automatically find all subtasks
        # If --with-subtasks flag is used, also include subtasks for subtasks (but that's unusual)
        if [[ "$id" != *.* ]] || [[ "$with_subtasks" == "true" ]]; then
            # Extract numeric part of parent ID for matching subtasks
            local parent_num=""
            if [[ "$id" =~ ^([a-z0-9]{1,7}-)?([0-9]+)$ ]]; then
                parent_num="${match[2]}"
            else
                parent_num="$id"
            fi
            
            # Find all direct subtasks and nested subtasks
            while IFS= read -r line; do
                # Match task IDs: **#task_id** or **#prefix-task_id**
                # Try with prefix first, then without
                local task_prefix=""
                local task_id=""
                local full_task_id=""
                
                # Pattern 1: With prefix (e.g., **#fxstein-57.1**)
                if [[ "$line" =~ '\*\*#([a-z0-9]{1,7})-([0-9]+(\.[0-9]+)+)\*\*' ]]; then
                    task_prefix="${match[1]}-"
                    task_id="${match[2]}"
                    full_task_id="${task_prefix}${task_id}"
                # Pattern 2: Without prefix (e.g., **#57.1**)
                elif [[ "$line" =~ '\*\*#([0-9]+(\.[0-9]+)+)\*\*' ]]; then
                    task_prefix=""
                    task_id="${match[1]}"
                    full_task_id="$task_id"
                fi
                
                if [[ -n "$task_id" ]]; then
                    # Extract numeric parent part from subtask (before the first dot)
                    local subtask_parent_num=""
                    if [[ "$task_id" =~ ^([0-9]+)\. ]]; then
                        subtask_parent_num="${match[1]}"
                    fi
                    
                    # Check if subtask belongs to this parent (by numeric part only, ignoring prefix)
                    if [[ -n "$subtask_parent_num" ]] && [[ "$subtask_parent_num" == "$parent_num" ]]; then
                        expanded_ids+=("$full_task_id")
                    fi
                fi
            done < "$TODO_FILE"
        fi
        done
        all_ids=("${expanded_ids[@]}")
    
    # Delete all tasks
    local deleted_count=0
    local delete_date=$(date +"%Y-%m-%d")
    local expire_date=$(date -d "+30 days" +"%Y-%m-%d" 2>/dev/null || date -v+30d +"%Y-%m-%d" 2>/dev/null || echo "2025-11-29")
    
    for number in "${all_ids[@]}"; do
        # Find task (anywhere - Tasks or Recently Completed, handles nested subtasks)
        # Try resolved ID first, then try original ID if resolution added a prefix that doesn't match
        local task_line=$(grep "^- \[.\] \*\*#$number\*\* \|^  - \[.\] \*\*#$number\*\* \|^    - \[.\] \*\*#$number\*\* " "$TODO_FILE" | head -1)
        
        # If not found and number has a prefix, try without prefix (fallback for tasks created before mode switch)
        if [[ -z "$task_line" ]] && [[ "$number" =~ ^[a-z0-9]{1,7}-([0-9]+(\.[0-9]+)?)$ ]]; then
            local number_without_prefix="${match[1]}"
            task_line=$(grep "^- \[.\] \*\*#${number_without_prefix}\*\* \|^  - \[.\] \*\*#${number_without_prefix}\*\* \|^    - \[.\] \*\*#${number_without_prefix}\*\* " "$TODO_FILE" | head -1)
            if [[ -n "$task_line" ]]; then
                # Found with original number - update number to match actual task ID
                number="$number_without_prefix"
            fi
        fi
        
        if [[ -z "$task_line" ]]; then
            echo "Warning: Task #$number not found, skipping"
            continue
        fi
        
        # Change checkbox to [D] and add deletion metadata
        task_line=$(echo "$task_line" | sed 's/\[.\]/[D]/')
        
        # Remove any existing date, then add deletion metadata
        task_line=$(echo "$task_line" | sed 's/ *([^)]*)$//')
        task_line="$task_line (deleted $delete_date, expires $expire_date)"
        
        # Find task line number to also remove following notes (handles nested subtasks at any level)
        # Use the actual number variable (which may have been updated to remove prefix)
        local task_line_num=$(grep -n "^- \[.\] \*\*#$number\*\* \|^  - \[.\] \*\*#$number\*\* \|^    - \[.\] \*\*#$number\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
        
        if [[ -n "$task_line_num" ]]; then
            # Remove the task line
            sed_inplace "${task_line_num}d" "$TODO_FILE"
            
            # Remove any following blockquote notes (lines starting with "  > ", "    > ", or "      > ")
            # Keep removing lines as long as they're blockquotes
            while true; do
                local next_line=$(sed -n "${task_line_num}p" "$TODO_FILE")
                if [[ "$next_line" =~ ^"  > " ]] || [[ "$next_line" =~ ^"    > " ]] || [[ "$next_line" =~ ^"      > " ]]; then
                    sed_inplace "${task_line_num}d" "$TODO_FILE"
                else
                    break
                fi
            done
        fi
        
        # Add to Deleted section
        ensure_deleted_section
        local deleted_section=$(grep -n "^## Deleted Tasks" "$TODO_FILE" | cut -d: -f1)
        if [[ -n "$deleted_section" ]]; then
            if [[ "$(uname)" == "Darwin" ]]; then
                local temp_file=$(mktemp)
                head -n "$deleted_section" "$TODO_FILE" > "$temp_file"
                echo "$task_line" >> "$temp_file"
                tail -n +$((deleted_section + 1)) "$TODO_FILE" >> "$temp_file"
                mv "$temp_file" "$TODO_FILE"
            else
                sed_inplace "${deleted_section}a$task_line" "$TODO_FILE"
            fi
        fi
        
        # Log the action
        local task_description=$(echo "$task_line" | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//' | sed 's/ *(deleted.*//')
        log_todo_action "DELETE" "$number" "$task_description"
        
        deleted_count=$((deleted_count + 1))
    done
    
    update_footer
    
    echo "Moved $deleted_count task(s) to Deleted section"
}

# Function to ensure Deleted Tasks section exists and is correctly positioned
ensure_deleted_section() {
    local deleted_section_line=$(grep -n "^## Deleted Tasks" "$TODO_FILE" | cut -d: -f1 | head -1)
    local footer_line=$(grep -n "^---$" "$TODO_FILE" | cut -d: -f1 | head -1)
    
    # Check if Deleted Tasks section exists but is after footer (wrong position)
    if [[ -n "$deleted_section_line" ]] && [[ -n "$footer_line" ]] && [[ $deleted_section_line -gt $footer_line ]]; then
        # Deleted Tasks section is after footer - need to move it before footer
        # This is a fix for existing incorrectly-positioned sections
        
        # Find Recently Completed section
        local recently_completed_line=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1 | head -1)
        
        if [[ -n "$recently_completed_line" ]]; then
            # Find where Deleted Tasks section ends (next section header or end of file)
            local deleted_next_section=$(awk "NR > $deleted_section_line && /^## / {print NR; exit}" "$TODO_FILE" || echo "")
            local deleted_end
            if [[ -n "$deleted_next_section" ]]; then
                deleted_end=$((deleted_next_section - 1))
            else
                deleted_end=$(wc -l < "$TODO_FILE" | tr -d ' ')
            fi
            
            # Extract Deleted Tasks section (including header and all tasks)
            local deleted_section=$(sed -n "${deleted_section_line},${deleted_end}p" "$TODO_FILE")
            
            # Remove Deleted Tasks section from original position
            if [[ "$(uname)" == "Darwin" ]]; then
                local temp_file=$(mktemp)
                head -n $((deleted_section_line - 1)) "$TODO_FILE" > "$temp_file"
                tail -n +$((deleted_end + 1)) "$TODO_FILE" >> "$temp_file" 2>/dev/null || true
                mv "$temp_file" "$TODO_FILE"
            else
                sed_inplace "${deleted_section_line},${deleted_end}d" "$TODO_FILE"
            fi
            
            # Recalculate footer line after deletion
            footer_line=$(grep -n "^---$" "$TODO_FILE" | cut -d: -f1 | head -1)
            
            # Insert Deleted Tasks section before footer
            if [[ -n "$footer_line" ]]; then
                local insert_line=$((footer_line - 1))
                
                if [[ "$(uname)" == "Darwin" ]]; then
                    local temp_file=$(mktemp)
                    head -n "$insert_line" "$TODO_FILE" > "$temp_file"
                    echo "" >> "$temp_file"
                    echo "$deleted_section" >> "$temp_file"
                    tail -n +$((insert_line + 1)) "$TODO_FILE" >> "$temp_file" 2>/dev/null || true
                    mv "$temp_file" "$TODO_FILE"
                else
                    sed_inplace "${insert_line}a\\\n$deleted_section" "$TODO_FILE"
                fi
            fi
        fi
    elif [[ -z "$deleted_section_line" ]]; then
        # Deleted Tasks section doesn't exist - create it after Recently Completed, but before footer
        local recently_completed_line=$(grep -n "^## Recently Completed" "$TODO_FILE" | cut -d: -f1)
        if [[ -n "$recently_completed_line" ]]; then
            # Find the footer boundary (---) or next section header (## )
            # Priority: check for footer first, then section headers
            local footer_after_recently=$(awk "NR > $recently_completed_line && /^---$/ {print NR; exit}" "$TODO_FILE" || echo "")
            local next_section_line=$(awk "NR > $recently_completed_line && /^## / {print NR; exit}" "$TODO_FILE" || echo "")
            
            local insert_line
            if [[ -n "$footer_after_recently" ]]; then
                # Footer exists - insert Deleted Tasks section before footer
                insert_line=$((footer_after_recently - 1))
            elif [[ -n "$next_section_line" ]]; then
                # Next section exists - insert before it
                insert_line=$((next_section_line - 1))
            else
                # No footer or section, insert at end of file
                insert_line=$(wc -l < "$TODO_FILE" | tr -d ' ')
            fi
            
            if [[ "$(uname)" == "Darwin" ]]; then
                # Use temporary file approach for macOS compatibility
                local temp_file=$(mktemp)
                head -n "$insert_line" "$TODO_FILE" > "$temp_file"
                echo "" >> "$temp_file"
                echo "## Deleted Tasks" >> "$temp_file"
                echo "" >> "$temp_file"
                tail -n +$((insert_line + 1)) "$TODO_FILE" >> "$temp_file" 2>/dev/null || true
                mv "$temp_file" "$TODO_FILE"
            else
                # Insert after the last line before next section
                sed_inplace "${insert_line}a\\\n## Deleted Tasks\n" "$TODO_FILE"
            fi
        fi
    fi
}

# Function to purge expired deleted tasks
purge_expired_deleted_tasks() {
    local current_date=$(date +"%Y-%m-%d")
    local purged_count=0
    
    # Find and remove expired tasks
    while IFS= read -r line; do
        if [[ "$line" =~ "expires ([0-9]{4}-[0-9]{2}-[0-9]{2})" ]]; then
            local expire_date="${match[1]}"
            # Compare dates (simple string comparison works for YYYY-MM-DD format)
            if [[ "$expire_date" < "$current_date" ]]; then
                # Task expired, remove it
                sed_inplace "/$(echo "$line" | sed 's/[]\/$*.^[]/\\&/g')/d" "$TODO_FILE"
                purged_count=$((purged_count + 1))
            fi
        fi
    done < <(grep "^\- \[D\]" "$TODO_FILE")
    
    if [[ $purged_count -gt 0 ]]; then
        echo "Auto-purged $purged_count expired task(s)" >&2
    fi
}

# Function to restore a task and its subtasks from Recently Completed to Tasks
restore_task() {
    local task_id="$1"
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai restore <id>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Simple implementation: move the task back to Tasks section
    # Get the task line (from Recently Completed or Deleted section)
    local task_line=$(grep "^- \[[xD~>\-]\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1)
    if [[ -z "$task_line" ]]; then
        echo "Error: Could not find task #$task_id in Recently Completed or Deleted section"
        return 1
    fi
    
    # Restore to [ ] checkbox and remove metadata
    task_line=$(echo "$task_line" | sed 's/\[.\]/[ ]/')
    task_line=$(echo "$task_line" | sed 's/ *(deleted.*//' | sed 's/ *(completed.*//' | sed 's/ *(.*)$//')
    
    # Remove from current section (Recently Completed or Deleted)
    sed_inplace "/^- \[[xD~>\-]\] \*\*#$task_id\*\* /d" "$TODO_FILE"
    
    # Add to Tasks section
    local tasks_section=$(grep -n "^## Tasks" "$TODO_FILE" | cut -d: -f1)
    if [[ -n "$tasks_section" ]]; then
        # Insert after the "## Tasks" line
        if [[ "$(uname)" == "Darwin" ]]; then
            local temp_file=$(mktemp)
            head -n "$tasks_section" "$TODO_FILE" > "$temp_file"
            echo "$task_line" >> "$temp_file"
            tail -n +$((tasks_section + 1)) "$TODO_FILE" >> "$temp_file"
            mv "$temp_file" "$TODO_FILE"
        else
            sed_inplace "${tasks_section}a$task_line" "$TODO_FILE"
        fi
    else
        echo "Error: Tasks section not found"
        return 1
    fi
    
    update_footer
    
    # Get task description for logging
    local task_description=$(echo "$task_line" | sed 's/.*\*\*#[0-9.]*\*\* *//' | sed 's/ *`.*$//' | sed 's/ *([^)]*)$//')
    
    # Log the action
    log_todo_action "RESTORE" "$task_id" "$task_description"
    
    echo "Restored task #$task_id to Tasks section"
}

# Function to ensure Task Metadata section exists
ensure_metadata_section() {
    if ! grep -q "^## Task Metadata" "$TODO_FILE"; then
        # Add metadata section at the end
        echo "" >> "$TODO_FILE"
        echo "## Task Metadata" >> "$TODO_FILE"
        echo "" >> "$TODO_FILE"
        echo "Task relationships and dependencies (managed by todo.ai tool)." >> "$TODO_FILE"
        echo "View with: \`./todo.ai show <task-id>\`" >> "$TODO_FILE"
        echo "" >> "$TODO_FILE"
        echo "<!-- TASK RELATIONSHIPS" >> "$TODO_FILE"
        echo "-->" >> "$TODO_FILE"
    fi
}

# Function to add a task relationship
add_relationship() {
    local task_id="$1"
    local rel_type="$2"
    local target_tasks="$3"
    
    # Ensure metadata section exists
    ensure_metadata_section
    
    # Remove any existing relationship of this type for this task
    sed_inplace "/^$task_id:$rel_type:/d" "$TODO_FILE"
    
    # Add new relationship before the closing -->
    sed_inplace "/^-->/i$task_id:$rel_type:$target_tasks" "$TODO_FILE"
    
    update_footer
}

# Function to remove a task relationship
remove_relationship() {
    local task_id="$1"
    local rel_type="$2"
    local target_task="$3"
    
    if [[ -n "$target_task" ]]; then
        # Remove specific target from relationship list
        # This is complex, for now just remove the whole relationship
        sed_inplace "/^$task_id:$rel_type:/d" "$TODO_FILE"
    else
        # Remove all relationships of this type for this task
        sed_inplace "/^$task_id:$rel_type:/d" "$TODO_FILE"
    fi
    
    update_footer
}

# Function to get relationships for a task
get_relationships() {
    local task_id="$1"
    
    # Extract relationships from metadata section
    sed -n '/<!-- TASK RELATIONSHIPS/,/-->/p' "$TODO_FILE" | \
        grep "^$task_id:" | \
        while IFS=: read -r id rel_type targets; do
            echo "$rel_type:$targets"
        done
}

# Function to detect available coordination options (#52.20)
detect_coordination_options() {
    local available_options=()
    local missing_requirements=()
    
    echo "üîç Detecting available coordination options..."
    echo ""
    
    # Check for GitHub Issues coordination
    echo "Checking GitHub Issues coordination..."
    local gh_available=false
    local gh_auth=false
    local git_repo=false
    
    if command -v gh >/dev/null 2>&1; then
        gh_available=true
        echo "  ‚úÖ GitHub CLI (gh) installed"
        
        # Check authentication
        if gh auth status >/dev/null 2>&1; then
            gh_auth=true
            echo "  ‚úÖ GitHub CLI authenticated"
        else
            echo "  ‚ö†Ô∏è  GitHub CLI not authenticated (run: gh auth login)"
            missing_requirements+=("GitHub CLI authentication")
        fi
    else
        echo "  ‚ùå GitHub CLI (gh) not installed"
        missing_requirements+=("GitHub CLI (gh)")
    fi
    
    # Check if we're in a git repository
    if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
        local repo_url=$(git config --get remote.origin.url 2>/dev/null || echo "")
        if [[ -n "$repo_url" ]] && [[ "$repo_url" =~ github\.com ]]; then
            git_repo=true
            echo "  ‚úÖ Git repository with GitHub remote detected"
        else
            echo "  ‚ö†Ô∏è  Git repository not connected to GitHub"
            missing_requirements+=("GitHub repository connection")
        fi
    else
        echo "  ‚ö†Ô∏è  Not in a Git repository"
        missing_requirements+=("Git repository")
    fi
    
    if [[ "$gh_available" == true ]] && [[ "$gh_auth" == true ]] && [[ "$git_repo" == true ]]; then
        available_options+=("github-issues")
        echo "  ‚úÖ GitHub Issues coordination: AVAILABLE"
    else
        echo "  ‚ùå GitHub Issues coordination: NOT AVAILABLE"
    fi
    echo ""
    
    # Check for CounterAPI coordination
    echo "Checking CounterAPI coordination..."
    local curl_available=false
    local jq_available=false
    local python_available=false
    
    if command -v curl >/dev/null 2>&1; then
        curl_available=true
        echo "  ‚úÖ curl installed"
    else
        echo "  ‚ùå curl not installed"
        missing_requirements+=("curl")
    fi
    
    if command -v jq >/dev/null 2>&1; then
        jq_available=true
        echo "  ‚úÖ jq installed"
    elif command -v python3 >/dev/null 2>&1; then
        python_available=true
        echo "  ‚úÖ python3 installed (can parse JSON)"
    else
        echo "  ‚ö†Ô∏è  Neither jq nor python3 available (JSON parsing will be limited)"
        missing_requirements+=("jq or python3")
    fi
    
    if [[ "$curl_available" == true ]] && ([[ "$jq_available" == true ]] || [[ "$python_available" == true ]]); then
        available_options+=("counterapi")
        echo "  ‚úÖ CounterAPI coordination: AVAILABLE"
    else
        echo "  ‚ùå CounterAPI coordination: NOT AVAILABLE"
    fi
    echo ""
    
    # Summary
    echo "üìä Summary:"
    echo "============"
    if [[ ${#available_options[@]} -eq 0 ]]; then
        echo "  ‚ùå No coordination options available"
        echo ""
        echo "Missing requirements:"
        for req in "${missing_requirements[@]}"; do
            echo "  - $req"
        done
        echo ""
        echo "üí° Recommendation: Use 'multi-user' or 'branch' mode (no coordination required)"
        return 1
    else
        echo "  ‚úÖ Available coordination options:"
        for option in "${available_options[@]}"; do
            case "$option" in
                "github-issues")
                    echo "    - GitHub Issues (github-issues)"
                    ;;
                "counterapi")
                    echo "    - CounterAPI (counterapi)"
                    ;;
            esac
        done
        echo ""
        if [[ ${#missing_requirements[@]} -gt 0 ]]; then
            echo "‚ö†Ô∏è  Note: Some options may require additional setup"
        fi
        return 0
    fi
}

# Function to set up coordination service (#52.21)
setup_coordination() {
    local coord_type="$1"
    local interactive=true
    
    # Parse arguments
    if [[ "$1" == "--non-interactive" ]]; then
        interactive=false
        coord_type="$2"
    fi
    
    if [[ -z "$coord_type" ]]; then
        echo "Error: Please specify coordination type"
        echo "Usage: ./todo.ai setup-coordination <type>"
        echo "Types: github-issues, counterapi"
        return 1
    fi
    
    local config_file=$(get_config_file)
    local config_dir=$(dirname "$config_file")
    
    # Ensure config directory exists
    mkdir -p "$config_dir" 2>/dev/null || return 1
    
    # Ensure config file exists
    # Get current mode (defaults to single-user if no config exists)
    local current_mode=$(get_numbering_mode)
    if [[ ! -f "$config_file" ]]; then
        cat > "$config_file" <<EOF
# todo.ai Configuration File
mode: $current_mode
coordination:
  type: none
  fallback: multi-user
EOF
    fi
    
    case "$coord_type" in
        "github-issues")
            setup_github_issues_coordination "$interactive"
            ;;
        "counterapi")
            setup_counterapi_coordination "$interactive"
            ;;
        *)
            echo "Error: Unknown coordination type '$coord_type'"
            echo "Valid types: github-issues, counterapi"
            return 1
            ;;
    esac
}

# Function to get current value from GitHub Issues coordination
get_current_github_issues_value() {
    local issue_num="$1"
    local repo_url="$2"
    
    if [[ -z "$issue_num" ]] || [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        echo "0"
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo "0"
        return 1
    fi
    
    # Get latest comment from issue
    local latest_comment=$(gh api repos/${repo_url}/issues/${issue_num}/comments --jq 'sort_by(.created_at) | .[-1].body' 2>/dev/null || echo "")
    
    if [[ -z "$latest_comment" ]]; then
        echo "0"
        return 0
    fi
    
    # Extract number from comment (format: "Next task number: 123" or just "123")
    local current_num=$(echo "$latest_comment" | grep -oE '[0-9]+' | tail -1)
    if [[ -z "$current_num" ]] || ! [[ "$current_num" =~ ^[0-9]+$ ]]; then
        echo "0"
        return 0
    fi
    
    echo "$current_num"
    return 0
}

# Function to get current value from current coordinator (if switching)
get_current_coordinator_value() {
    local current_coord_type=$(get_config_value "coordination.type" "none")
    
    case "$current_coord_type" in
        "github-issues")
            local issue_num=$(get_config_value "coordination.issue_number" "")
            local repo_url=$(git config --get remote.origin.url 2>/dev/null | sed 's/\.git$//' | sed 's/.*github\.com[:/]//' || echo "")
            if [[ -n "$issue_num" ]] && [[ -n "$repo_url" ]]; then
                get_current_github_issues_value "$issue_num" "$repo_url"
                return 0
            fi
            ;;
        "counterapi")
            # CounterAPI doesn't have a GET endpoint, we can't reliably get current value
            # So we'll just return 0 and rely on TODO.md highest number
            echo "0"
            return 0
            ;;
    esac
    
    echo "0"
    return 0
}

# Function to get highest task number from TODO.md
get_highest_task_number() {
    local highest=0
    
    if [[ ! -f "$TODO_FILE" ]]; then
        echo "0"
        return 0
    fi
    
    # Scan all task IDs in TODO.md (handle both prefixed and non-prefixed formats)
    # ONLY scan actual task lines, not examples in notes/blockquotes
    while IFS= read -r line; do
        # Skip blockquote lines (notes/examples) - they start with '>'
        if [[ "$line" =~ ^[[:space:]]*\> ]]; then
            continue
        fi
        
        # Skip lines that don't contain task checkbox pattern
        if [[ ! "$line" =~ ^[[:space:]]*- ]]; then
            continue
        fi
        
        # Match task IDs in format: **#task_id** or **#prefix-task_id**
        # Use unquoted pattern variable for zsh regex compatibility
        local task_pattern='\*\*#([0-9a-z.\-]+)\*\*'
        if [[ "$line" =~ $task_pattern ]]; then
            local full_task_id="${match[1]}"  # BASH_CONVERT: BASH_REMATCH[1]
            
            # Extract numeric part (removes prefix if present, ignores subtasks)
            local numeric_part=$(extract_task_number "$full_task_id" 2>/dev/null)
            if [[ -z "$numeric_part" ]]; then
                # Try extracting just the main number (not subtask)
                if [[ "$full_task_id" =~ ^([0-9]+)(\.[0-9]+)?$ ]]; then
                    numeric_part="${match[1]}"  # BASH_CONVERT: BASH_REMATCH[1]
                elif [[ "$full_task_id" =~ ^[a-z0-9]{1,7}-([0-9]+)(\.[0-9]+)?$ ]]; then
                    numeric_part="${match[1]}"  # BASH_CONVERT: BASH_REMATCH[1]
                fi
            fi
            
            if [[ -n "$numeric_part" ]] && [[ "$numeric_part" =~ ^[0-9]+$ ]]; then
                # Extract main number (ignore subtask part)
                local main_num="${numeric_part%%.*}"
                if [[ $main_num -gt $highest ]]; then
                    highest=$main_num
                fi
            fi
        fi
    done < "$TODO_FILE"
    
    echo "$highest"
}

# Function to set up GitHub Issues coordination
setup_github_issues_coordination() {
    local interactive="$1"
    local config_file=$(get_config_file)
    
    echo "üîß Setting up GitHub Issues coordination..."
    echo ""
    
    # Verify prerequisites
    if ! command -v gh >/dev/null 2>&1; then
        echo "‚ùå Error: GitHub CLI (gh) is not installed"
        echo "   Install: https://cli.github.com/manual/installation"
        return 1
    fi
    
    if ! gh auth status >/dev/null 2>&1; then
        echo "‚ùå Error: GitHub CLI is not authenticated"
        echo "   Run: gh auth login"
        return 1
    fi
    
    # Get repository URL
    local repo_url=$(git config --get remote.origin.url 2>/dev/null || echo "")
    if [[ -z "$repo_url" ]] || [[ ! "$repo_url" =~ github\.com ]]; then
        echo "‚ùå Error: Not in a GitHub repository"
        return 1
    fi
    
    # Extract repo owner/name
    local repo_identifier=$(echo "$repo_url" | sed 's/\.git$//' | sed 's/.*github\.com[:/]//')
    
    echo "Repository: $repo_identifier"
    echo ""
    
    # Auto-detect existing coordination issue or create new one
    local issue_title="todo.ai Task Number Coordination"
    local issue_number=""
    
    echo "Searching for existing coordination issue..."
    # Search for issues with the coordination title (check both open and closed issues)
    local existing_issues=$(gh issue list --repo "$repo_identifier" --state all --search "todo.ai Task Number Coordination" --json number,title --jq '.[].number' 2>/dev/null || echo "")
    
    if [[ -n "$existing_issues" ]]; then
        # Use the first matching issue
        issue_number=$(echo "$existing_issues" | head -1)
        echo "‚úÖ Found existing coordination issue #$issue_number"
    else
        # No existing issue found, create a new one
        echo "   No existing coordination issue found"
        echo ""
        echo "Creating new GitHub issue for task coordination..."
        local issue_body="This issue is used by todo.ai for atomic task number coordination.
        
Do not manually comment on this issue - it is managed automatically by todo.ai."
        
        # gh issue create returns a URL like: https://github.com/owner/repo/issues/123
        local issue_output=$(gh issue create --repo "$repo_identifier" --title "$issue_title" --body "$issue_body" 2>&1)
        
        # Extract issue number from URL (format: https://github.com/owner/repo/issues/123)
        if [[ "$issue_output" =~ /issues/([0-9]+)$ ]] || [[ "$issue_output" =~ issues/([0-9]+) ]]; then
            issue_number="${match[1]}"
        elif [[ "$issue_output" =~ ([0-9]+) ]]; then
            # Fallback: just extract any number from output
            issue_number=$(echo "$issue_output" | grep -oE '[0-9]+' | tail -1)
        fi
        
        if [[ -z "$issue_number" ]]; then
            echo "‚ùå Error: Failed to create GitHub issue"
            echo "   Output: $issue_output"
            return 1
        fi
        
        echo "‚úÖ Created issue #$issue_number"
    fi
    
    # Initialize issue with max(highest_task_number, current_coordinator_value) + 1 if it has no comments
    echo ""
    echo "Checking issue comments..."
    local existing_comments=$(gh api repos/${repo_identifier}/issues/${issue_number}/comments --jq 'length' 2>/dev/null || echo "0")
    
    # Always check and sync with TODO.md highest number, even if issue has comments
    local highest_num=$(get_highest_task_number)
    local current_coord_value=$(get_current_coordinator_value)
    
    # Get max of highest_num and current_coord_value
    local max_value=$highest_num
    if [[ $current_coord_value -gt $max_value ]]; then
        max_value=$current_coord_value
    fi
    
    if [[ "$existing_comments" == "0" ]] || [[ -z "$existing_comments" ]]; then
        # No comments yet - initialize with max of highest task number from TODO.md and current coordinator value
        local start_num=$((max_value + 1))
        
        if [[ $highest_num -gt 0 ]] || [[ $current_coord_value -gt 0 ]]; then
            echo "   Found existing tasks in TODO.md (highest: #$highest_num)"
            if [[ $current_coord_value -gt 0 ]]; then
                echo "   Found current coordinator value: #$current_coord_value"
            fi
            echo "   Initializing coordination with task number: $start_num"
        else
            echo "   No existing tasks found - starting from 1"
            start_num=1
        fi
        
        # Post initial comment with starting number
        if ! gh api -X POST repos/${repo_identifier}/issues/${issue_number}/comments --field "body=Next task number: $start_num" >/dev/null 2>&1; then
            echo "‚ö†Ô∏è  Warning: Failed to initialize issue with starting number"
            echo "   You may need to manually post a comment with: Next task number: $start_num"
        else
            echo "‚úÖ Initialized issue with starting number: $start_num"
        fi
    else
        # Issue has comments - check if coordinator is behind TODO.md and sync if needed
        local latest_comment=$(gh api repos/${repo_identifier}/issues/${issue_number}/comments --jq 'sort_by(.created_at) | .[-1].body' 2>/dev/null || echo "")
        local current_num=$(echo "$latest_comment" | grep -oE '[0-9]+' | tail -1)
        if [[ -n "$current_num" ]]; then
            echo "   Current task number in coordination: $current_num"
            
            # If coordinator is behind TODO.md, update it
            if [[ $current_num -lt $highest_num ]]; then
                local sync_num=$((max_value + 1))
                echo "   ‚ö†Ô∏è  Coordinator ($current_num) is behind TODO.md highest ($highest_num)"
                echo "   Updating coordination to: $sync_num"
                
                # Post sync comment with correct number
                if gh api -X POST repos/${repo_identifier}/issues/${issue_number}/comments --field "body=Next task number: $sync_num" >/dev/null 2>&1; then
                    echo "   ‚úÖ Coordinator synced to: $sync_num"
                else
                    echo "   ‚ö†Ô∏è  Warning: Failed to sync coordinator"
                fi
            fi
        fi
    fi
    echo ""
    
    # Update config file
    if command -v yq >/dev/null 2>&1; then
        yq eval ".coordination.type = \"github-issues\"" -i "$config_file" 2>/dev/null
        yq eval ".coordination.issue_number = $issue_number" -i "$config_file" 2>/dev/null
    elif command -v python3 >/dev/null 2>&1 && python3 -c "import yaml" 2>/dev/null; then
        python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f) or {}
    if 'coordination' not in config:
        config['coordination'] = {}
    config['coordination']['type'] = 'github-issues'
    config['coordination']['issue_number'] = int('$issue_number')
    with open('$config_file', 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
except Exception as e:
            print(f"Error: {e}", file=sys.stderr)
            sys.exit(1)
EOF
        if [[ $? -ne 0 ]]; then
            echo "‚ùå Error: Failed to update config file"
            return 1
        fi
    else
        # Fallback to sed for simple coordination updates (always available)
        # NOTE: We ALWAYS use sed fallback when YAML parsers are missing - never show errors
        # Ensure coordination section exists
        if ! grep -q "^coordination:" "$config_file"; then
            # Add coordination section after mode line
            sed_inplace "/^mode:/a\\
coordination:\\
  type: none\\
  fallback: multi-user" "$config_file"
        fi
        
        # Update coordination.type
        if grep -q "^  type:" "$config_file"; then
            sed_inplace "s/^  type:.*/  type: github-issues/" "$config_file"
        else
            # Add type line if it doesn't exist
            sed_inplace "/^coordination:/a\\
  type: github-issues" "$config_file"
        fi
        
    # Remove namespace if it exists (switching from counterapi)
    if grep -q "^  namespace:" "$config_file"; then
        sed_inplace "/^  namespace:/d" "$config_file"
    fi
    
    # Update or add issue_number
    if grep -q "^  issue_number:" "$config_file"; then
        sed_inplace "s/^  issue_number:.*/  issue_number: $issue_number/" "$config_file"
    else
        # Add issue_number line after type
        sed_inplace "/^  type: github-issues/a\\
  issue_number: $issue_number" "$config_file"
    fi
    fi
    
    echo ""
    echo "‚úÖ GitHub Issues coordination configured"
    echo "   Issue: #$issue_number"
    echo "   Repository: $repo_identifier"
    return 0
}

# Function to set up CounterAPI coordination
setup_counterapi_coordination() {
    local interactive="$1"
    local config_file=$(get_config_file)
    
    echo "üîß Setting up CounterAPI coordination..."
    echo ""
    
    # Verify prerequisites
    if ! command -v curl >/dev/null 2>&1; then
        echo "‚ùå Error: curl is not installed"
        return 1
    fi
    
    if ! command -v jq >/dev/null 2>&1 && ! command -v python3 >/dev/null 2>&1; then
        echo "‚ùå Error: jq or python3 required for JSON parsing"
        return 1
    fi
    
    # Get namespace
    local namespace=""
    if [[ "$interactive" == true ]]; then
        # Suggest default namespace based on repo name
        local repo_name=""
        if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
            local repo_url=$(git config --get remote.origin.url 2>/dev/null || echo "")
            if [[ "$repo_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                repo_name="${match[2]%.git}"
            fi
        fi
        
        local default_namespace="${repo_name:-todo-ai-$(date +%s)}"
        printf "Enter CounterAPI namespace [$default_namespace]: "
        read -r namespace
        namespace=${namespace:-$default_namespace}
    else
        namespace="${COUNTERAPI_NAMESPACE:-}"
        if [[ -z "$namespace" ]]; then
            echo "‚ùå Error: COUNTERAPI_NAMESPACE environment variable not set"
            return 1
        fi
    fi
    
    # Validate namespace (should be alphanumeric with hyphens/underscores)
    if [[ ! "$namespace" =~ ^[a-z0-9_-]+$ ]]; then
        echo "‚ùå Error: Namespace must contain only lowercase letters, numbers, hyphens, and underscores"
        return 1
    fi
    
    # Test CounterAPI connection
    echo ""
    echo "Testing CounterAPI connection..."
    local test_response=$(curl -s -X POST "https://api.counterapi.dev/v1/${namespace}/test-counter/up" 2>/dev/null || echo "")
    
    if [[ -z "$test_response" ]]; then
        echo "‚ö†Ô∏è  Warning: Could not reach CounterAPI"
        printf "Continue anyway? (y/N): "
        read -r continue_anyway
        if [[ ! "$continue_anyway" =~ ^[Yy]$ ]]; then
            return 1
        fi
    else
        echo "‚úÖ CounterAPI connection successful"
    fi
    
    # Initialize counter with max(highest_task_number, current_coordinator_value) + 1
    echo ""
    echo "Initializing counter with max of TODO.md and current coordinator..."
    local highest_num=$(get_highest_task_number)
    local current_coord_value=$(get_current_coordinator_value)
    
    # Get max of highest_num and current_coord_value
    local max_value=$highest_num
    if [[ $current_coord_value -gt $max_value ]]; then
        max_value=$current_coord_value
    fi
    
    local start_num=$((max_value + 1))
    
    if [[ $highest_num -gt 0 ]] || [[ $current_coord_value -gt 0 ]]; then
        echo "   Found existing tasks in TODO.md (highest: #$highest_num)"
        if [[ $current_coord_value -gt 0 ]]; then
            echo "   Found current coordinator value: #$current_coord_value"
        fi
        echo "   Counter will start from: $start_num"
        echo "   Note: CounterAPI increments atomically - first task will use $start_num"
    else
        echo "   No existing tasks found - counter will start from 1"
        echo "   Note: CounterAPI increments atomically - first task will use 1"
        start_num=1
    fi
    echo ""
    
    # Update config file
    # NOTE: We ALWAYS use sed fallback when YAML parsers are missing - never show errors
    if command -v yq >/dev/null 2>&1; then
        yq eval ".coordination.type = \"counterapi\"" -i "$config_file" 2>/dev/null
        yq eval ".coordination.namespace = \"$namespace\"" -i "$config_file" 2>/dev/null
    elif command -v python3 >/dev/null 2>&1 && python3 -c "import yaml" 2>/dev/null; then
        python3 <<EOF
import yaml
import sys
try:
    with open('$config_file', 'r') as f:
        config = yaml.safe_load(f) or {}
    if 'coordination' not in config:
        config['coordination'] = {}
    config['coordination']['type'] = 'counterapi'
    config['coordination']['namespace'] = '$namespace'
    with open('$config_file', 'w') as f:
        yaml.dump(config, f, default_flow_style=False, sort_keys=False)
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
EOF
        if [[ $? -ne 0 ]]; then
            # Fallback to sed if Python YAML fails
            echo "‚ö†Ô∏è  Python YAML update failed, using sed fallback..."
        else
            # Success - return early
            echo ""
            echo "‚úÖ CounterAPI coordination configured"
            echo "   Namespace: $namespace"
            return 0
        fi
    fi
    
    # Fallback to sed for simple coordination updates (always available)
    # Ensure coordination section exists
    if ! grep -q "^coordination:" "$config_file"; then
        # Add coordination section after mode line
        sed_inplace "/^mode:/a\\
coordination:\\
  type: none\\
  fallback: multi-user" "$config_file"
    fi
    
    # Update coordination.type
    if grep -q "^  type:" "$config_file"; then
        sed_inplace "s/^  type:.*/  type: counterapi/" "$config_file"
    else
        # Add type line if it doesn't exist
        sed_inplace "/^coordination:/a\\
  type: counterapi" "$config_file"
    fi
    
    # Update or add namespace
    if grep -q "^  namespace:" "$config_file"; then
        sed_inplace "s/^  namespace:.*/  namespace: $namespace/" "$config_file"
    else
        # Add namespace line after type
        sed_inplace "/^  type: counterapi/a\\
  namespace: $namespace" "$config_file"
    fi
    
    # Remove issue_number if it exists (switching from github-issues)
    if grep -q "^  issue_number:" "$config_file"; then
        sed_inplace "/^  issue_number:/d" "$config_file"
    fi
    
    echo ""
    echo "‚úÖ CounterAPI coordination configured"
    echo "   Namespace: $namespace"
    return 0
}

# Function to run setup wizard (#52.23)
setup_wizard() {
    echo "üöÄ todo.ai Setup Wizard"
    echo "========================"
    echo ""
    echo "This wizard will guide you through configuring todo.ai for your needs."
    echo ""
    
    # Step 1: Detect current system capabilities
    echo "Step 1: Detecting system capabilities..."
    echo ""
    if ! detect_coordination_options; then
        echo ""
        echo "‚ö†Ô∏è  No coordination options available - using simpler modes"
    fi
    echo ""
    
    # Step 2: Select mode
    echo "Step 2: Select numbering mode"
    echo ""
    echo "Available modes:"
    echo "  1) single-user  - Simple sequential numbering (#1, #2, #3...)"
    echo "  2) multi-user   - Prefix with GitHub user ID (fxstein-50, alice-50...)"
    echo "  3) branch       - Prefix with branch name (feature-50, main-50...)"
    echo "  4) enhanced     - Multi-user with atomic coordination (requires setup)"
    echo ""
    printf "Enter mode [1]: "
    read -r mode_choice
    mode_choice=${mode_choice:-1}
    
    local selected_mode=""
    case "$mode_choice" in
        1) selected_mode="single-user" ;;
        2) selected_mode="multi-user" ;;
        3) selected_mode="branch" ;;
        4) selected_mode="enhanced" ;;
        *)
            echo "‚ùå Invalid choice"
            return 1
            ;;
    esac
    
    echo ""
    echo "‚úÖ Selected mode: $selected_mode"
    echo ""
    
    # Step 3: Switch to selected mode
    echo "Step 3: Switching to $selected_mode mode..."
    if ! switch_mode "$selected_mode" --force; then
        echo "‚ùå Failed to switch mode"
        return 1
    fi
    echo ""
    
    # Step 4: Set up coordination if enhanced mode
    if [[ "$selected_mode" == "enhanced" ]]; then
        echo "Step 4: Setting up coordination..."
        echo ""
        
        # Detect available options
        local available=()
        if command -v gh >/dev/null 2>&1 && gh auth status >/dev/null 2>&1 && \
           git rev-parse --git-dir >/dev/null 2>&1 && \
           git config --get remote.origin.url 2>/dev/null | grep -q github\.com; then
            available+=("github-issues")
        fi
        
        if command -v curl >/dev/null 2>&1 && \
           (command -v jq >/dev/null 2>&1 || command -v python3 >/dev/null 2>&1); then
            available+=("counterapi")
        fi
        
        if [[ ${#available[@]} -eq 0 ]]; then
            echo "‚ö†Ô∏è  No coordination services available"
            echo "   Enhanced mode will fall back to multi-user mode"
            echo ""
        else
            echo "Available coordination options:"
            local index=1
            for option in "${available[@]}"; do
                case "$option" in
                    "github-issues")
                        echo "  $index) GitHub Issues"
                        ;;
                    "counterapi")
                        echo "  $index) CounterAPI"
                        ;;
                esac
                index=$((index + 1))
            done
            echo "  $index) Skip (use fallback mode)"
            echo ""
            printf "Enter choice [$index]: "
            read -r coord_choice
            coord_choice=${coord_choice:-$index}
            
            if [[ $coord_choice -ge 1 ]] && [[ $coord_choice -le ${#available[@]} ]]; then
                local selected_coord="${available[$((coord_choice - 1))]}"
                echo ""
                setup_coordination "$selected_coord" || {
                    echo "‚ö†Ô∏è  Coordination setup failed, continuing with fallback mode"
                }
            else
                echo "Skipping coordination setup (using fallback mode)"
            fi
            echo ""
        fi
    fi
    
    # Step 5: Summary
    echo "‚úÖ Setup complete!"
    echo ""
    echo "Current configuration:"
    show_config
    echo ""
    echo "You can now use todo.ai. Try: ./todo.ai add 'Your first task'"
}

# Function to show current configuration
show_config() {
    local config_file=$(get_config_file)
    
    if [[ ! -f "$config_file" ]]; then
        echo "No configuration file found."
        echo "Using default mode: single-user"
        echo ""
        echo "To create a config file, use: ./todo.ai switch-mode <mode>"
        return 0
    fi
    
    echo "Current Configuration:"
    echo "======================"
    cat "$config_file"
    echo ""
    echo "Config file location: $config_file"
}

# Function to show a task with its relationships
show_task() {
    local task_id="$1"
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai show <id>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    
    # Find and display the task (try resolved ID first, then fall back to original if not found)
    # Support arbitrary nesting depth by matching any amount of leading spaces
    # Use [.*] instead of [.] to handle checkbox variations (including malformed ones)
    local task_line=$(grep "^[ ]*- \[.*\] \*\*#$resolved_task_id\*\* " "$TODO_FILE" | head -1)
    
    # Fallback: if resolved ID not found and it has a prefix, try original plain number
    if [[ -z "$task_line" ]] && [[ "$resolved_task_id" != "$task_id" ]] && [[ "$resolved_task_id" =~ ^[a-z0-9]{1,7}-([0-9]+(\.[0-9]+)?)$ ]]; then
        local plain_number="${match[1]}"
        task_line=$(grep "^[ ]*- \[.*\] \*\*#${plain_number}\*\* " "$TODO_FILE" | head -1)
        if [[ -n "$task_line" ]]; then
            task_id="$plain_number"  # Use plain number for display
        fi
    else
        task_id="$resolved_task_id"  # Use resolved ID for display
    fi
    
    if [[ -z "$task_line" ]]; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    echo "$task_line"
    
    # Get line number for note detection
    # Support arbitrary nesting depth by matching any amount of leading spaces
    # Use [.*] instead of [.] to handle checkbox variations (including malformed ones)
    local task_line_num=$(grep -n "^[ ]*- \[.*\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    # Display notes if they exist (blockquotes immediately after task)
    # Support arbitrary nesting depth by matching any amount of leading spaces
    if [[ -n "$task_line_num" ]]; then
        local next_line_num=$((task_line_num + 1))
        local next_line=$(sed -n "${next_line_num}p" "$TODO_FILE")
        while [[ "$next_line" =~ ^[[:space:]]*\>  ]]; do
            echo "$next_line"
            next_line_num=$((next_line_num + 1))
            next_line=$(sed -n "${next_line_num}p" "$TODO_FILE")
        done
    fi
    
    # Find and display subtasks with their notes if this is a parent
    if [[ "$task_id" != *.* ]]; then
        # First, collect all subtasks
        local subtask_lines=()
        while IFS= read -r subtask; do
            subtask_lines+=("$subtask")
        done < <(grep "^  - \[.\] \*\*#$task_id\." "$TODO_FILE")
        
        # Display each subtask with its notes and sub-subtasks
        for subtask_line in "${subtask_lines[@]}"; do
            echo "$subtask_line"
            
            # Extract subtask ID from the line
            local subtask_id=$(echo "$subtask_line" | grep -o "#${task_id}\.[0-9.]*" | sed 's/^#//')
            
            # Display notes for this subtask
            local subtask_notes=$(collect_task_notes "$subtask_id")
            if [[ -n "$subtask_notes" ]]; then
                echo "$subtask_notes"
            fi
            
            # Display sub-subtasks for this subtask
            while IFS= read -r subsubtask; do
                echo "$subsubtask"
                
                # Extract sub-subtask ID and display its notes
                local subsubtask_id=$(echo "$subsubtask" | grep -o "#${subtask_id}\.[0-9.]*" | sed 's/^#//')
                local subsubtask_notes=$(collect_task_notes "$subsubtask_id")
                if [[ -n "$subsubtask_notes" ]]; then
                    echo "$subsubtask_notes"
                fi
            done < <(grep "^    - \[.\] \*\*#${subtask_id}\." "$TODO_FILE")
        done
    fi
    
    # Display relationships if any exist
    local has_relationships=false
    while IFS=: read -r rel_type targets; do
        if [[ -n "$rel_type" ]]; then
            has_relationships=true
            # Format relationship type (replace - with space, capitalize)
            local formatted_type=""
            case "$rel_type" in
                completed-by) formatted_type="Completed by" ;;
                depends-on) formatted_type="Depends on" ;;
                blocks) formatted_type="Blocks" ;;
                related-to) formatted_type="Related to" ;;
                duplicate-of) formatted_type="Duplicate of" ;;
                *) formatted_type="$rel_type" ;;
            esac
            echo "  ‚Ü≥ $formatted_type: $targets"
        fi
    done < <(get_relationships "$task_id")
    
    if [[ "$has_relationships" == false ]]; then
        echo "  (No relationships)"
    fi
}

# Function to manage task relationships
relate_task() {
    local task_id=""
    local rel_type=""
    local targets=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --completed-by)
                rel_type="completed-by"
                targets="$2"
                shift 2
                ;;
            --depends-on)
                rel_type="depends-on"
                targets="$2"
                shift 2
                ;;
            --blocks)
                rel_type="blocks"
                targets="$2"
                shift 2
                ;;
            --related-to)
                rel_type="related-to"
                targets="$2"
                shift 2
                ;;
            --duplicate-of)
                rel_type="duplicate-of"
                targets="$2"
                shift 2
                ;;
            *)
                task_id="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$task_id" ]] || [[ -z "$rel_type" ]] || [[ -z "$targets" ]]; then
        echo "Error: Missing required parameters"
        echo "Usage: ./todo.ai relate <id> --<relation-type> <target-ids>"
        echo ""
        echo "Relation types:"
        echo "  --completed-by <ids>   Task completed by other task(s)"
        echo "  --depends-on <ids>     Task depends on other task(s)"
        echo "  --blocks <ids>         Task blocks other task(s)"
        echo "  --related-to <ids>     General relationship"
        echo "  --duplicate-of <id>    Task is duplicate of another"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Verify task exists
    if ! grep -q "\*\*#$task_id\*\*" "$TODO_FILE"; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    # Add the relationship
    add_relationship "$task_id" "$rel_type" "$targets"
    
    # Log the action
    log_todo_action "RELATE" "$task_id" "$rel_type: $targets"
    
    echo "Added relationship: #$task_id $rel_type $targets"
}

# Function to add a note to a task (using blockquote format)
add_note() {
    local task_id="$1"
    local note_text="$2"
    
    if [[ -z "$task_id" ]] || [[ -z "$note_text" ]]; then
        echo "Error: Please provide task ID and note text"
        echo "Usage: ./todo.ai note <id> <note-text>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Verify task exists (support arbitrary nesting depth)
    local task_line_num=$(grep -n "^[ ]*- \[.*\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    if [[ -z "$task_line_num" ]]; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    # Format note as blockquote with proper indentation
    # Detect indentation from task line to support arbitrary nesting depth
    local task_line=$(sed -n "${task_line_num}p" "$TODO_FILE")
    local indent=""
    # Extract leading spaces before the dash
    indent=$(echo "$task_line" | sed 's/^\([[:space:]]*\)-.*/\1/')
    
    # Create blockquote note with proper formatting for multi-line text
    # Split note_text by newlines and add indent + "> " to each line
    local formatted_note=""
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ -n "$formatted_note" ]]; then
            formatted_note="${formatted_note}"$'\n'
        fi
        formatted_note="${formatted_note}${indent}  > ${line}"
    done <<< "$note_text"
    
    # Insert note after the task line
    if [[ "$(uname)" == "Darwin" ]]; then
        local temp_file=$(mktemp)
        head -n "$task_line_num" "$TODO_FILE" > "$temp_file"
        echo "$formatted_note" >> "$temp_file"
        tail -n +$((task_line_num + 1)) "$TODO_FILE" >> "$temp_file"
        mv "$temp_file" "$TODO_FILE"
    else
        # For Linux, need to escape newlines for sed
        local escaped_note=$(echo "$formatted_note" | sed ':a;N;$!ba;s/\n/\\n/g')
        sed_inplace "${task_line_num}a\\${escaped_note}" "$TODO_FILE"
    fi
    
    update_footer
    
    # Log the action
    log_todo_action "NOTE" "$task_id" "$note_text"
    
    echo "Added note to task #$task_id"
}

# Delete all notes from a task
delete_note() {
    local task_id="$1"
    
    if [[ -z "$task_id" ]]; then
        echo "Error: Please provide task ID"
        echo "Usage: ./todo.ai delete-note <id>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Check if task exists and has notes
    local notes=$(collect_task_notes "$task_id")
    if [[ -z "$notes" ]]; then
        echo "Error: Task #$task_id has no notes to delete"
        return 1
    fi
    
    # Count note lines
    local note_count=$(echo "$notes" | wc -l | tr -d ' ')
    
    # Show confirmation prompt
    echo "Task #$task_id has $note_count line(s) of notes."
    printf "Delete all notes from task #$task_id? (y/N) "
    read -r reply
    
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        echo "Cancelled - notes not deleted"
        return 0
    fi
    
    # Delete the notes
    delete_notes_only "$task_id"
    
    update_footer
    
    # Log the action
    log_todo_action "DELETE_NOTE" "$task_id" "Deleted $note_count line(s) of notes"
    
    echo "Deleted notes from task #$task_id"
}

# Update/replace all notes for a task
update_note() {
    local task_id="$1"
    local new_note_text="$2"
    
    if [[ -z "$task_id" ]] || [[ -z "$new_note_text" ]]; then
        echo "Error: Please provide task ID and new note text"
        echo "Usage: ./todo.ai update-note <id> <new-note-text>"
        return 1
    fi
    
    # Resolve task reference (auto-add prefix for number-only references)
    local resolved_task_id=$(resolve_task_reference "$task_id" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$resolved_task_id" ]]; then
        resolved_task_id="$task_id"
    fi
    task_id="$resolved_task_id"
    
    # Check if task exists and has notes
    local old_notes=$(collect_task_notes "$task_id")
    if [[ -z "$old_notes" ]]; then
        echo "Error: Task #$task_id has no notes to update"
        echo "Hint: Use './todo.ai note $task_id \"text\"' to add notes"
        return 1
    fi
    
    # Count old and new note lines
    local old_count=$(echo "$old_notes" | wc -l | tr -d ' ')
    local new_count=$(echo "$new_note_text" | wc -l)
    
    # Show preview
    echo "Task #$task_id currently has $old_count line(s) of notes."
    echo "New note will have $new_count line(s)."
    printf "Replace notes for task #$task_id? (y/N) "
    read -r reply
    
    if [[ ! "$reply" =~ ^[Yy]$ ]]; then
        echo "Cancelled - notes not updated"
        return 0
    fi
    
    # Delete old notes (without confirmation since we already confirmed)
    delete_notes_only "$task_id"
    
    # Add new notes using existing add_note logic
    # We need to manually do what add_note does but without the existence check
    
    # Find task and get indentation
    local task_line_num=$(grep -n "^[ ]*- \[.*\] \*\*#$task_id\*\* " "$TODO_FILE" | head -1 | cut -d: -f1)
    
    if [[ -z "$task_line_num" ]]; then
        echo "Error: Task #$task_id not found"
        return 1
    fi
    
    local task_line=$(sed -n "${task_line_num}p" "$TODO_FILE")
    local indent=""
    indent=$(echo "$task_line" | sed 's/^\([[:space:]]*\)-.*/\1/')
    
    # Format new note with proper multi-line handling
    local formatted_note=""
    while IFS= read -r line || [[ -n "$line" ]]; do
        if [[ -n "$formatted_note" ]]; then
            formatted_note="${formatted_note}"$'\n'
        fi
        formatted_note="${formatted_note}${indent}  > ${line}"
    done <<< "$new_note_text"
    
    # Insert new note after the task line
    if [[ "$(uname)" == "Darwin" ]]; then
        local temp_file=$(mktemp)
        head -n "$task_line_num" "$TODO_FILE" > "$temp_file"
        echo "$formatted_note" >> "$temp_file"
        tail -n +$((task_line_num + 1)) "$TODO_FILE" >> "$temp_file"
        mv "$temp_file" "$TODO_FILE"
    else
        # For Linux, need to escape newlines for sed
        local escaped_note=$(echo "$formatted_note" | sed ':a;N;$!ba;s/\n/\\n/g')
        sed_inplace "${task_line_num}a\\${escaped_note}" "$TODO_FILE"
    fi
    
    update_footer
    
    # Log the action
    log_todo_action "UPDATE_NOTE" "$task_id" "Updated note (was $old_count lines, now $new_count lines)"
    
    echo "Updated note for task #$task_id"
}

# Function to lint (identify) formatting issues
lint_todo() {
    local issues_found=0
    
    echo "üîç Checking TODO.md for formatting issues..."
    echo ""
    
    # Track which section we're in (skip Archived and Deleted)
    local in_tasks=false
    local in_recently_completed=false
    local in_deleted=false
    local skip_line=false
    
    # Check for indentation issues
    echo "üìã Checking indentation:"
    local indent_issues=0
    
    # Find subtasks that are not properly indented (should start with "  -")
    while IFS= read -r line; do
        # Detect section headers
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks=true
            in_recently_completed=false
            in_deleted=false
            skip_line=false
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=false
            in_recently_completed=true
            in_deleted=false
            skip_line=true
        elif [[ "$line" == "## Deleted Tasks" ]]; then
            in_tasks=false
            in_recently_completed=false
            in_deleted=true
            skip_line=true
        elif [[ "$line" =~ ^"## " ]]; then
            # Other section - stop checking
            in_tasks=false
            in_recently_completed=false
            in_deleted=false
            skip_line=true
        fi
        
        # Skip archived and deleted tasks
        if [[ "$skip_line" == true ]]; then
            continue
        fi
        
        # Only check tasks in the "Tasks" section
        if [[ "$in_tasks" == true ]]; then
        if [[ "$line" =~ "^- \[.*\] \*\*#[0-9]+\.[0-9]+\*\* " ]]; then
            echo "  ‚ùå Subtask not indented: $line"
            indent_issues=$((indent_issues + 1))
            issues_found=$((issues_found + 1))
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $indent_issues -eq 0 ]]; then
        echo "  ‚úÖ All subtasks properly indented"
    else
        echo "  üìä Found $indent_issues indentation issues"
    fi
    echo ""
    
    # Check for malformed checkboxes
    echo "‚òëÔ∏è  Checking checkboxes:"
    local checkbox_issues=0
    
    # Reset section tracking
    in_tasks=false
    in_recently_completed=false
    in_deleted=false
    skip_line=false
    
    # Find malformed checkboxes
    while IFS= read -r line; do
        # Detect section headers
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks=true
            in_recently_completed=false
            in_deleted=false
            skip_line=false
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=false
            in_recently_completed=true
            in_deleted=false
            skip_line=true
        elif [[ "$line" == "## Deleted Tasks" ]]; then
            in_tasks=false
            in_recently_completed=false
            in_deleted=true
            skip_line=true
        elif [[ "$line" =~ ^"## " ]]; then
            # Other section - stop checking
            in_tasks=false
            in_recently_completed=false
            in_deleted=false
            skip_line=true
        fi
        
        # Skip archived and deleted tasks
        if [[ "$skip_line" == true ]]; then
            continue
        fi
        
        # Only check tasks in the "Tasks" section
        if [[ "$in_tasks" == true ]]; then
        if [[ "$line" =~ "^- \[.*\] " || "$line" =~ "^  - \[.*\] " ]]; then
            # Check for various malformed checkbox patterns
            if [[ "$line" =~ "\[  \]" || "$line" =~ "\[   \]" || "$line" =~ "\[    \]" || "$line" =~ "\[\]" ]]; then
                echo "  ‚ùå Malformed checkbox: $line"
                checkbox_issues=$((checkbox_issues + 1))
                issues_found=$((issues_found + 1))
                fi
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $checkbox_issues -eq 0 ]]; then
        echo "  ‚úÖ All checkboxes properly formatted"
    else
        echo "  üìä Found $checkbox_issues checkbox issues"
    fi
    echo ""
    
    # Check for orphaned subtasks (subtasks without parent tasks)
    echo "üîó Checking for orphaned subtasks:"
    local orphan_issues=0
    local seen_parents=()
    
    # Reset section tracking
    in_tasks=false
    in_recently_completed=false
    in_deleted=false
    skip_line=false
    
    # First pass: collect all parent task IDs (only in Tasks section)
    while IFS= read -r line; do
        # Detect section headers
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks=true
            in_recently_completed=false
            in_deleted=false
            skip_line=false
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=false
            in_recently_completed=true
            in_deleted=false
            skip_line=true
        elif [[ "$line" == "## Deleted Tasks" ]]; then
            in_tasks=false
            in_recently_completed=false
            in_deleted=true
            skip_line=true
        elif [[ "$line" =~ ^"## " ]]; then
            # Other section - stop checking
            in_tasks=false
            in_recently_completed=false
            in_deleted=false
            skip_line=true
        fi
        
        # Only collect parents from Tasks section
        if [[ "$in_tasks" == true ]]; then
        if [[ "$line" == "- ["*"**#"*"**"* ]] && [[ "$line" != *"**#"*"."*"**"* ]]; then
                local parent_id=$(echo "$line" | grep -o '#[a-z0-9-]*[0-9]\+' | sed 's/#//' | head -1)
                if [[ -n "$parent_id" ]]; then
            seen_parents+=("$parent_id")
                fi
            fi
        fi
    done < "$TODO_FILE"
    
    # Reset section tracking for second pass
    in_tasks=false
    in_recently_completed=false
    in_deleted=false
    skip_line=false
    
    # Second pass: check all subtasks have parents (only in Tasks section)
    while IFS= read -r line; do
        # Detect section headers
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks=true
            in_recently_completed=false
            in_deleted=false
            skip_line=false
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=false
            in_recently_completed=true
            in_deleted=false
            skip_line=true
        elif [[ "$line" == "## Deleted Tasks" ]]; then
            in_tasks=false
            in_recently_completed=false
            in_deleted=true
            skip_line=true
        elif [[ "$line" =~ ^"## " ]]; then
            # Other section - stop checking
            in_tasks=false
            in_recently_completed=false
            in_deleted=false
            skip_line=true
        fi
        
        # Skip archived and deleted tasks
        if [[ "$skip_line" == true ]]; then
            continue
        fi
        
        # Only check subtasks in Tasks section
        if [[ "$in_tasks" == true ]]; then
            if [[ "$line" =~ '\*\*#([a-z0-9-]*[0-9]+)\.([0-9]+)\*\*' ]]; then
            local parent_id="${match[1]}"
            local subtask_id="${match[1]}.${match[2]}"
            if [[ ! " ${seen_parents[@]} " =~ " ${parent_id} " ]]; then
                echo "  ‚ùå Orphaned subtask #$subtask_id (parent #$parent_id not found)"
                orphan_issues=$((orphan_issues + 1))
                issues_found=$((issues_found + 1))
            fi
        fi
        fi
    done < "$TODO_FILE"
    
    if [[ $orphan_issues -eq 0 ]]; then
        echo "  ‚úÖ No orphaned subtasks"
    else
        echo "  üìä Found $orphan_issues orphaned subtasks"
    fi
    echo ""
    
    # Check for duplicate task IDs
    echo "üî¢ Checking for duplicate task IDs:"
    local duplicate_issues=0
    local task_ids=()
    local duplicates=()
    
    # Reset section tracking
    in_tasks=false
    in_recently_completed=false
    in_deleted=false
    skip_line=false
    
    while IFS= read -r line; do
        # Detect section headers
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks=true
            in_recently_completed=false
            in_deleted=false
            skip_line=false
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=false
            in_recently_completed=true
            in_deleted=false
            skip_line=true
        elif [[ "$line" == "## Deleted Tasks" ]]; then
            in_tasks=false
            in_recently_completed=false
            in_deleted=true
            skip_line=true
        elif [[ "$line" =~ ^"## " ]]; then
            # Other section - stop checking
            in_tasks=false
            in_recently_completed=false
            in_deleted=false
            skip_line=true
        fi
        
        # Skip archived and deleted tasks
        if [[ "$skip_line" == true ]]; then
            continue
        fi
        
        # Only check tasks in the "Tasks" section
        if [[ "$in_tasks" == true ]]; then
            # Match task IDs: **#task_id** or **#prefix-task_id**
            if [[ "$line" =~ '\*\*#([a-z0-9-]*[0-9]+(\.[0-9]+)?)\*\*' ]]; then
            local task_id="${match[1]}"
            if [[ " ${task_ids[@]} " =~ " ${task_id} " ]]; then
                if [[ ! " ${duplicates[@]} " =~ " ${task_id} " ]]; then
                    echo "  ‚ùå Duplicate task ID: #$task_id"
                    duplicates+=("$task_id")
                    duplicate_issues=$((duplicate_issues + 1))
                    issues_found=$((issues_found + 1))
                fi
            else
                task_ids+=("$task_id")
            fi
        fi
        fi
    done < "$TODO_FILE"
    
    if [[ $duplicate_issues -eq 0 ]]; then
        echo "  ‚úÖ No duplicate task IDs"
    else
        echo "  üìä Found $duplicate_issues duplicate task IDs"
    fi
    echo ""
    
    # Check for empty lines in task sections
    echo "üìÑ Checking for problematic empty lines:"
    local empty_line_issues=0
    
    # Reset section tracking
    in_tasks=false
    in_recently_completed=false
    in_deleted=false
    skip_line=false
    local line_num=0
    
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        
        # Detect section headers
        if [[ "$line" == "## Tasks" ]]; then
            in_tasks=true
            in_recently_completed=false
            in_deleted=false
            skip_line=false
        elif [[ "$line" == "## Recently Completed" ]]; then
            in_tasks=false
            in_recently_completed=true
            in_deleted=false
            skip_line=true
        elif [[ "$line" == "## Deleted Tasks" ]]; then
            in_tasks=false
            in_recently_completed=false
            in_deleted=true
            skip_line=true
        elif [[ "$line" =~ ^"## " ]]; then
            # Other section - stop checking
            in_tasks=false
            in_recently_completed=false
            in_deleted=false
            skip_line=true
        elif [[ "$in_tasks" == true ]] && [[ -z "$line" ]]; then
            # Only check empty lines in Tasks section
            # Check if previous and next lines are both tasks (not blockquotes or other content)
            local prev_line=$(sed -n "$((line_num-1))p" "$TODO_FILE")
            local next_line=$(sed -n "$((line_num+1))p" "$TODO_FILE")
            # Empty line between tasks is problematic
            if [[ "$prev_line" == "- ["*"**#"* ]] && [[ "$next_line" == "- ["*"**#"* ]]; then
                echo "  ‚ö†Ô∏è  Empty line between tasks at line $line_num"
                empty_line_issues=$((empty_line_issues + 1))
                issues_found=$((issues_found + 1))
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ $empty_line_issues -eq 0 ]]; then
        echo "  ‚úÖ No problematic empty lines"
    else
        echo "  üìä Found $empty_line_issues empty line issues"
    fi
    echo ""
    
    # Summary
    if [[ $issues_found -eq 0 ]]; then
        echo "üéâ No formatting issues found! TODO.md is properly formatted."
    else
        echo "‚ö†Ô∏è  Found $issues_found total formatting issues"
        echo "üí° Run './todo.ai --reformat --dry-run' to see what would be fixed"
        echo "üí° Run './todo.ai --reformat' to apply fixes"
    fi
}

# Function to detect and resolve task ID conflicts
resolve_conflicts() {
    local dry_run=false
    
    # Check for --dry-run flag
    if [[ "$1" == "--dry-run" ]]; then
        dry_run=true
        echo "üîç DRY RUN: Showing what would be fixed..."
    else
        echo "üîß Resolving task ID conflicts..."
    fi
    echo ""
    
    local conflicts_resolved=0
    
    # Step 1: Detect duplicate task IDs
    local task_ids=()
    local duplicates=()
    local duplicate_lines=()  # Store line numbers for duplicates
    
    local line_num=0
    while IFS= read -r line; do
        line_num=$((line_num + 1))
        # Match task IDs in format: **#task_id** or **#prefix-task_id**
        # Also match prefixed IDs like fxstein-50
        # Use unquoted pattern variable for zsh regex compatibility
        local task_pattern='\*\*#([^ ]+)\*\*'
        if [[ "$line" =~ $task_pattern ]]; then
            local task_id="${match[1]}"
            
            # Check if this task ID has been seen before
            local found_duplicate=false
            for existing_id in "${task_ids[@]}"; do
                if [[ "$existing_id" == "$task_id" ]]; then
                    found_duplicate=true
                    # Check if we already recorded this duplicate
                    local already_recorded=false
                    for dup_id in "${duplicates[@]}"; do
                        if [[ "$dup_id" == "$task_id" ]]; then
                            already_recorded=true
                            break
                        fi
                    done
                    if [[ "$already_recorded" == false ]]; then
                        duplicates+=("$task_id")
                    fi
                    duplicate_lines+=("$line_num|$task_id")
                    break
                fi
            done
            
            # Add to seen IDs
            if [[ "$found_duplicate" == false ]]; then
                task_ids+=("$task_id")
            fi
        fi
    done < "$TODO_FILE"
    
    if [[ ${#duplicates[@]} -eq 0 ]]; then
        echo "‚úÖ No duplicate task IDs found"
        return 0
    fi
    
    echo "üìä Found ${#duplicates[@]} duplicate task ID(s):"
    for dup_id in "${duplicates[@]}"; do
        echo "  - #$dup_id"
    done
    echo ""
    
    # Step 2: Create mapping from old duplicate IDs to new IDs
    # Strategy: Keep first occurrence, renumber subsequent ones
    declare -A id_mapping  # old_id -> new_id
    local mode=$(get_numbering_mode)
    
    for dup_id in "${duplicates[@]}"; do
        # Find all occurrences of this duplicate
        local occurrences=()
        local first_line_num=""
        local occurrence_count=0
        
        line_num=0
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            # Use unquoted pattern variable for zsh regex compatibility
            local dup_pattern="\\*\\*#${dup_id}\\*\\*"
            if [[ "$line" =~ $dup_pattern ]]; then
                if [[ -z "$first_line_num" ]]; then
                    first_line_num="$line_num"
                else
                    # This is a duplicate - needs renumbering
                    occurrences+=("$line_num")
                fi
                occurrence_count=$((occurrence_count + 1))
            fi
        done < "$TODO_FILE"
        
        # Renumber each duplicate occurrence (except the first)
        local occurrence_index=1
        for dup_line_num in "${occurrences[@]}"; do
            # Generate new ID based on mode
            local new_id=""
            
            # Extract numeric part and prefix if any
            local numeric_part=""
            local prefix_part=""
            
            if [[ "$dup_id" =~ ^([a-z0-9]{1,7}-)?([0-9]+)(\.([0-9]+))?$ ]]; then
                prefix_part="${match[1]}"
                numeric_part="${match[2]}"
                if [[ -n "${match[4]}" ]]; then
                    # Subtask - preserve parent number, only renumber subtask part
                    local parent_num="$numeric_part"
                    local subtask_num="${match[4]}"
                    # Get next available subtask number for this parent
                    local next_subtask=$((subtask_num + occurrence_index))
                    new_id="${prefix_part}${parent_num}.${next_subtask}"
                else
                    # Main task - get next available number
                    # Find highest number in TODO.md for this prefix
                    local highest_num=0
                    for seen_id in "${task_ids[@]}"; do
                        if [[ "$seen_id" =~ ^${prefix_part}([0-9]+)(\.([0-9]+))?$ ]]; then
                            local seen_num="${match[1]}"
                            if [[ $seen_num -gt $highest_num ]]; then
                                highest_num=$seen_num
                            fi
                        fi
                    done
                    local next_num=$((highest_num + occurrence_index))
                    new_id="${prefix_part}${next_num}"
                fi
            else
                # Fallback: append occurrence index
                new_id="${dup_id}-dup${occurrence_index}"
            fi
            
            # Make sure new_id doesn't conflict with existing IDs
            local conflict=true
            local conflict_index=1
            while [[ "$conflict" == true ]]; do
                conflict=false
                for existing_id in "${task_ids[@]}"; do
                    if [[ "$existing_id" == "$new_id" ]]; then
                        conflict=true
                        # Adjust new_id
                        if [[ "$dup_id" =~ ^([a-z0-9]{1,7}-)?([0-9]+)(\.([0-9]+))?$ ]]; then
                            prefix_part="${match[1]}"
                            numeric_part="${match[2]}"
                            if [[ -n "${match[4]}" ]]; then
                                local parent_num="$numeric_part"
                                local subtask_num="${match[4]}"
                                local next_subtask=$((subtask_num + occurrence_index + conflict_index))
                                new_id="${prefix_part}${parent_num}.${next_subtask}"
                            else
                                local next_num=$((occurrence_index + conflict_index))
                                new_id="${prefix_part}${next_num}"
                            fi
                        else
                            new_id="${dup_id}-dup${occurrence_index}-${conflict_index}"
                        fi
                        conflict_index=$((conflict_index + 1))
                        break
                    fi
                done
            done
            
            # Add to mapping
            id_mapping["${dup_line_num}|${dup_id}"]="$new_id"
            occurrence_index=$((occurrence_index + 1))
        done
    done
    
    # Step 3: Apply renumbering
    if [[ "$dry_run" == true ]]; then
        echo "üìã Would renumber the following tasks:"
        # Use zsh-compatible syntax for associative array keys
        for key in "${(@k)id_mapping}"; do
            # Parse key safely: format is "line_num|old_id"
            # Strip any quotes and whitespace from line_num
            local line_num=$(echo "$key" | cut -d'|' -f1 | tr -d '"' | tr -d "'" | tr -d '[:space:]')
            local old_id=$(echo "$key" | cut -d'|' -f2- | tr -d '"' | tr -d "'")
            local new_id="${id_mapping[$key]}"
            
            # Validate line_num is a number
            if [[ "$line_num" =~ ^[0-9]+$ ]]; then
                local task_line=$(sed -n "${line_num}p" "$TODO_FILE")
                echo "  Line $line_num: #$old_id ‚Üí #$new_id"
                echo "    $task_line"
            else
                echo "  ‚ö†Ô∏è  Invalid line number format: '$line_num' (key: '$key')"
            fi
        done
        echo ""
        echo "üí° Run './todo.ai resolve-conflicts' to apply these changes"
    else
        # Create backup before making changes
        local backup_name=$(create_mode_backup 2>/dev/null || echo "")
        
        # Apply changes by reading file and replacing IDs
        local temp_file=$(mktemp)
        local line_num=0
        
        while IFS= read -r line; do
            line_num=$((line_num + 1))
            local new_line="$line"
            local line_changed=false
            
            # Check if this line needs renumbering
            # Use zsh-compatible syntax for associative array keys
            for key in "${(@k)id_mapping}"; do
                # Parse key safely: format is "line_num|old_id"
                # Strip any quotes and whitespace from dup_line_num
                local dup_line_num=$(echo "$key" | cut -d'|' -f1 | tr -d '"' | tr -d "'" | tr -d '[:space:]')
                local old_id=$(echo "$key" | cut -d'|' -f2- | tr -d '"' | tr -d "'")
                
                # Validate dup_line_num is a number before comparing
                if [[ "$dup_line_num" =~ ^[0-9]+$ ]] && [[ "$line_num" == "$dup_line_num" ]]; then
                    local new_id="${id_mapping[$key]}"
                    # Replace task ID in line
                    new_line=$(echo "$new_line" | sed "s/\\*\\*#${old_id}\\*\\*/\\*\\*#${new_id}\\*\\*/g")
                    line_changed=true
                    conflicts_resolved=$((conflicts_resolved + 1))
                    echo "  ‚úÖ Renumbered: Line $line_num: #$old_id ‚Üí #$new_id"
                    break
                fi
            done
            
            # Also update references to old IDs in relationships, notes, etc.
            if [[ "$line_changed" == false ]]; then
                # Use zsh-compatible syntax for associative array keys
                for key in "${(@k)id_mapping}"; do
                    # Parse key safely: format is "line_num|old_id"
                    # Strip any quotes from old_id (line_num not needed here)
                    local old_id=$(echo "$key" | cut -d'|' -f2- | tr -d '"' | tr -d "'")
                    local new_id="${id_mapping[$key]}"
                    # Replace references (e.g., in relationships: #old_id or old_id:)
                    if [[ "$new_line" =~ "#${old_id}" ]] || [[ "$new_line" =~ ":${old_id}" ]] || [[ "$new_line" =~ "${old_id}:" ]]; then
                        new_line=$(echo "$new_line" | sed "s/#${old_id}\\([^0-9a-z-]\\|$\\)/#${new_id}\\1/g")
                        new_line=$(echo "$new_line" | sed "s/:${old_id}\\([^0-9a-z-]\\|$\\)/:${new_id}\\1/g")
                        new_line=$(echo "$new_line" | sed "s/${old_id}:\\([^0-9a-z-]\\|$\\)/${new_id}:\\1/g")
                    fi
                done
            fi
            
            echo "$new_line" >> "$temp_file"
        done < "$TODO_FILE"
        
        # Replace original file
        mv "$temp_file" "$TODO_FILE"
        
        update_footer
        
        # Log the action
        log_todo_action "RESOLVE_CONFLICTS" "${#duplicates[@]}" "Resolved ${#duplicates[@]} duplicate task ID(s)"
        
        if [[ -n "$backup_name" ]]; then
            echo ""
            echo "üíæ Backup created: $backup_name"
        fi
    fi
    
    echo ""
    if [[ "$dry_run" == true ]]; then
        echo "üí° Run './todo.ai resolve-conflicts' to apply these changes"
    elif [[ $conflicts_resolved -gt 0 ]]; then
        echo "‚úÖ Resolved $conflicts_resolved conflict(s)"
    else
        echo "‚úÖ No conflicts found"
    fi
}

# Function to reformat (fix) formatting issues
reformat_todo() {
    local dry_run=false
    
    # Check for --dry-run flag
    if [[ "$1" == "--dry-run" ]]; then
        dry_run=true
        echo "üîç DRY RUN: Showing what would be fixed..."
    else
        echo "üîß Applying formatting fixes..."
    fi
    echo ""
    
    local fixes_applied=0
    
    # Fix indentation issues
    echo "üìã Fixing indentation:"
    local indent_fixes=0
    
    # Find subtasks that are not properly indented
    while IFS= read -r line; do
        if [[ "$line" =~ "^- \[.*\] \*\*#[0-9]+\.[0-9]+\*\* " ]]; then
            local fixed_line="  $line"
            if [[ "$dry_run" == true ]]; then
                echo "  üîÑ Would fix: $line"
                echo "  ‚û°Ô∏è  To:        $fixed_line"
            else
                sed_inplace "s|^$line|$fixed_line|" "$TODO_FILE"
                echo "  ‚úÖ Fixed: $line"
            fi
            indent_fixes=$((indent_fixes + 1))
            fixes_applied=$((fixes_applied + 1))
        fi
    done < "$TODO_FILE"
    
    if [[ $indent_fixes -eq 0 ]]; then
        echo "  ‚úÖ No indentation issues found"
    else
        if [[ "$dry_run" == true ]]; then
            echo "  üìä Would fix $indent_fixes indentation issues"
        else
            echo "  üìä Fixed $indent_fixes indentation issues"
        fi
    fi
    echo ""
    
    # Fix checkbox issues
    echo "‚òëÔ∏è  Fixing checkboxes:"
    local checkbox_fixes=0
    
    # Check if there are malformed checkboxes
    if grep -q "\[  \]\|\[   \]\|\[    \]\|\[\]" "$TODO_FILE"; then
        if [[ "$dry_run" == true ]]; then
            echo "  üîÑ Would fix malformed checkboxes:"
            grep -n "\[  \]\|\[   \]\|\[    \]\|\[\]" "$TODO_FILE" | while read -r line; do
                echo "    Line: $line"
            done
        else
            # Use the existing normalize_checkboxes function directly
            normalize_checkboxes
            echo "  ‚úÖ Fixed malformed checkboxes"
        fi
        checkbox_fixes=$((checkbox_fixes + 1))
        fixes_applied=$((fixes_applied + 1))
    fi
    
    if [[ $checkbox_fixes -eq 0 ]]; then
        echo "  ‚úÖ No checkbox issues found"
    else
        if [[ "$dry_run" == true ]]; then
            echo "  üìä Would fix $checkbox_fixes checkbox patterns"
        else
            echo "  üìä Fixed $checkbox_fixes checkbox patterns"
        fi
    fi
    echo ""
    
    # Summary
    if [[ "$dry_run" == true ]]; then
        echo "üí° Run './todo.ai --reformat' to apply these fixes"
    elif [[ $fixes_applied -gt 0 ]]; then
        echo "üéâ Applied $fixes_applied formatting fixes to TODO.md"
    else
        echo "üéâ No formatting issues found - TODO.md is already properly formatted!"
    fi
}

# Function to edit todo file
edit_todo() {
    ${EDITOR:-nano} "$TODO_FILE"
}

# Function to view TODO log
view_log() {
    local filter="$1"
    local lines="$2"
    
    if [[ ! -f "$LOG_FILE" ]]; then
        echo "No log file found at $LOG_FILE"
        return 1
    fi
    
    echo "üìã TODO Tool Log"
    echo "================="
    echo ""
    
    if [[ -n "$filter" ]]; then
        echo "Filtering by: $filter"
        echo ""
        grep -i "$filter" "$LOG_FILE" | head -n "${lines:-50}"
    else
        head -n "${lines:-50}" "$LOG_FILE"
    fi
}

# Function to check for updates (informational only)
check_version() {
    if ! command -v curl >/dev/null 2>&1; then
        return 0
    fi
    
    # Try to get version from remote script
    local remote_version=$(curl -s "$SCRIPT_URL" | grep -i "^# Version:" | head -1 | sed 's/.*Version:[ ]*\([0-9.]*\).*/\1/' || echo "")
    
    if [[ -z "$remote_version" ]]; then
        # Try alternative extraction method
        remote_version=$(curl -s "$SCRIPT_URL" | grep -i "VERSION=" | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "")
    fi
    
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        echo ""
        echo "üí° Update available: $VERSION ‚Üí $remote_version"
        echo "   Run './todo.ai update' to update to latest version"
        return 1
    fi
    
    return 0
}

# Function to ensure backups directory exists
init_backups_dir() {
    local backups_dir="$(pwd)/.todo.ai/backups"
    if [[ ! -d "$backups_dir" ]]; then
        mkdir -p "$backups_dir" 2>/dev/null || return 1
    fi
    echo "$backups_dir"
}

# Function to get script path
get_script_path() {
    local script_path
    
    # Strategy 1: Try zsh-specific absolute path (works when script is executed directly)
    if [[ -f "${0:a}" ]] && [[ "${0:a}" =~ ^/ ]]; then
        script_path="${0:a}"
    # Strategy 2: If script is executed via PATH, use command -v/which to find it
    elif command -v todo.ai >/dev/null 2>&1; then
        # Get the actual path from PATH
        script_path=$(command -v todo.ai 2>/dev/null || which todo.ai 2>/dev/null || echo "")
        # Verify it exists and is readable
        if [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]]; then
            script_path=""
        fi
    # Strategy 3: Try current directory
    elif [[ -f "$(pwd)/todo.ai" ]]; then
        script_path="$(pwd)/todo.ai"
    # Strategy 4: Try relative path
    elif [[ -f "./todo.ai" ]]; then
        script_path="./todo.ai"
    else
        return 1
    fi
    
    # Ensure we found a valid path
    if [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]]; then
        return 1
    fi
    
    # Ensure absolute path
    if [[ ! "$script_path" =~ ^/ ]]; then
        script_path="$(cd "$(dirname "$script_path")" 2>/dev/null && pwd)/$(basename "$script_path")"
        # If cd failed, try realpath if available
        if [[ ! "$script_path" =~ ^/ ]] && command -v realpath >/dev/null 2>&1; then
            script_path=$(realpath "$script_path" 2>/dev/null || echo "$script_path")
        fi
    fi
    
    # Final verification
    if [[ -z "$script_path" ]] || [[ ! -f "$script_path" ]] || [[ ! "$script_path" =~ ^/ ]]; then
        return 1
    fi
    
    echo "$script_path"
}

# Function to get todo.ai path for cursor rules (handles different installation scenarios)
get_todo_ai_path_for_rules() {
    # Check if we're in the developer repo (todo.ai repository itself)
    local is_dev_repo=false
    if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
        local remote_url=$(git remote get-url origin 2>/dev/null || echo "")
        if [[ -n "$remote_url" ]]; then
            # Check if this is the todo.ai repository
            # zsh regex: match array is stored in $match
            if [[ "$remote_url" =~ github\.com[:/]([^/]+)/([^/]+)(\.git)?$ ]]; then
                local repo_owner="${match[1]}"
                local repo_name="${match[2]%.git}"
                # Check if this is the fxstein/todo.ai repository
                if [[ "$repo_name" == "todo.ai" ]] && [[ "$repo_owner" == "fxstein" ]]; then
                    is_dev_repo=true
                fi
            fi
        fi
    fi
    
    # If in developer repo, use relative path (current behavior)
    if [[ "$is_dev_repo" == true ]]; then
        echo "./todo.ai"
        return 0
    fi
    
    # Strategy 1: Check if tool is in PATH (works for global installs)
    if command -v todo.ai >/dev/null 2>&1; then
        local path_location=$(which todo.ai 2>/dev/null || command -v todo.ai 2>/dev/null)
        if [[ -n "$path_location" ]]; then
            # If in a standard bin directory, just use command name (no path needed)
            if [[ "$path_location" == *"/bin/todo.ai" ]] || [[ "$path_location" == *"/usr/local/bin/todo.ai" ]] || [[ "$path_location" == *"/usr/bin/todo.ai" ]]; then
                echo "todo.ai"
                return 0
            fi
        fi
    fi
    
    # Strategy 2: Check if script is in current directory (project-specific install)
    local current_dir="$(pwd)"
    if [[ -f "${current_dir}/todo.ai" ]]; then
        echo "./todo.ai"
        return 0
    fi
    
    # Strategy 3: Use script's own location (most reliable fallback)
    local script_path
    script_path=$(get_script_path) || {
        # Fallback: try to detect from $0
        if [[ -f "${0:a}" ]]; then
            script_path="${0:a}"
        else
            echo "./todo.ai"  # Final fallback
            return 0
        fi
    }
    
    # Convert absolute path to relative if possible
    if [[ "$script_path" =~ ^"${current_dir}"/(.+) ]]; then
        # Script is within current directory - use relative path
        echo "./${match[1]}"
    elif [[ "$script_path" =~ ^"${HOME}"/(.+) ]]; then
        # Script is in home directory - use ~/path
        echo "~/${match[1]}"
    else
        # Use absolute path as last resort
        echo "$script_path"
    fi
}

# Function to list available backups
list_backups() {
    local backups_dir
    backups_dir=$(init_backups_dir) || {
        echo "Error: Cannot access backups directory"
        return 1
    }
    
    # Check if any backups exist using find to avoid glob expansion issues
    local backup_files=$(find "$backups_dir" -maxdepth 1 -name "todo.ai.*" -type f 2>/dev/null)
    if [[ -z "$backup_files" ]]; then
        echo "No backups available"
        return 0
    fi
    
    echo "Available backups:"
    echo ""
    
    # Sort by modification time (newest first)
    local sorted_backups=($(echo "$backup_files" | xargs ls -t 2>/dev/null))
    
    local index=1
    for backup in "${sorted_backups[@]}"; do
        local filename=$(basename "$backup")
        local timestamp=$(echo "$filename" | sed 's/todo\.ai\.//')
        local version=$(grep -i "VERSION=" "$backup" 2>/dev/null | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "unknown")
        local date_str=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M:%S" "$backup" 2>/dev/null || stat -c "%y" "$backup" 2>/dev/null | cut -d'.' -f1 || echo "unknown")
        
        if [[ $index -eq 1 ]]; then
            echo "  [$index] $timestamp (v$version) - $date_str [LATEST]"
        else
            echo "  [$index] $timestamp (v$version) - $date_str"
        fi
        ((index++))
    done
    echo ""
    echo "Use './todo.ai rollback [index|timestamp]' to restore a backup"
}

# Function to rollback to a previous version
rollback() {
    local backups_dir
    backups_dir=$(init_backups_dir) || {
        echo "Error: Cannot access backups directory"
        return 1
    }
    
    local script_path
    script_path=$(get_script_path) || {
        echo "Error: Cannot locate todo.ai script"
        return 1
    }
    
    local backup_files=$(find "$backups_dir" -maxdepth 1 -name "todo.ai.*" -type f 2>/dev/null)
    if [[ -z "$backup_files" ]]; then
        echo "Error: No backups available"
        return 1
    fi
    
    local sorted_backups=($(echo "$backup_files" | xargs ls -t 2>/dev/null))
    
    local target_backup=""
    
    if [[ $# -eq 0 ]]; then
        # Default: rollback to latest backup
        target_backup="${sorted_backups[1]}"
    elif [[ "$1" =~ ^[0-9]+$ ]]; then
        # Index specified
        local index=$1
        if [[ $index -ge 1 ]] && [[ $index -le ${#sorted_backups[@]} ]]; then
            target_backup="${sorted_backups[$index]}"
        else
            echo "Error: Invalid backup index. Use './todo.ai backups' to see available backups"
            return 1
        fi
    else
        # Timestamp or version specified
        local search_term="$1"
        for backup in "${sorted_backups[@]}"; do
            local filename=$(basename "$backup")
            local timestamp=$(echo "$filename" | sed 's/todo\.ai\.//')
            local version=$(grep -i "VERSION=" "$backup" 2>/dev/null | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "")
            
            if [[ "$timestamp" == "$search_term" ]] || [[ "$version" == "$search_term" ]]; then
                target_backup="$backup"
                break
            fi
        done
        
        if [[ -z "$target_backup" ]]; then
            echo "Error: No backup found matching '$search_term'"
            echo "Use './todo.ai backups' to see available backups"
            return 1
        fi
    fi
    
    if [[ ! -f "$target_backup" ]]; then
        echo "Error: Backup file not found"
        return 1
    fi
    
    # Confirm rollback
    local backup_version=$(grep -i "VERSION=" "$target_backup" 2>/dev/null | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "unknown")
    local current_version="$VERSION"
    local backup_name=$(basename "$target_backup")
    
    echo "‚ö†Ô∏è  Rollback Warning:"
    echo "   Current version: $current_version"
    echo "   Backup version:  $backup_version"
    echo "   Backup file:     $backup_name"
    echo ""
    echo "This will replace the current script with the backup version."
    echo "Continue? (y/N)"
    read -r response
    if [[ ! "$response" =~ ^[Yy]$ ]]; then
        echo "Rollback cancelled"
        return 0
    fi
    
    # Create a backup of current version before rollback
    local timestamp=$(date +"%Y%m%d%H%M%S")
    cp "$script_path" "$backups_dir/todo.ai.$timestamp" 2>/dev/null || true
    
    # Restore from backup
    cp "$target_backup" "$script_path" || {
        echo "Error: Failed to restore backup"
        return 1
    }
    
    chmod +x "$script_path"
    
    echo "‚úÖ Rolled back to version $backup_version"
    echo "   Current version backed up as: todo.ai.$timestamp"
}

# Function to update todo.ai to latest version
update_tool() {
    # Get the actual script path
    local script_path
    script_path=$(get_script_path) || {
        echo "Error: Cannot locate todo.ai script"
        return 1
    }
    
    local backups_dir
    backups_dir=$(init_backups_dir) || {
        echo "Error: Cannot create backups directory"
        return 1
    }
    
    echo "üîÑ Updating todo.ai..."
    
    if ! command -v curl >/dev/null 2>&1; then
        echo "Error: curl is required to update todo.ai"
        echo "Please download manually from: $REPO_URL"
        return 1
    fi
    
    # Check if already at latest version
    local remote_version=$(curl -s "$SCRIPT_URL" | grep -i "VERSION=" | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "")
    
    # If version matches, check content hash to detect changes even with same version
    if [[ -n "$remote_version" ]] && [[ "$remote_version" == "$VERSION" ]]; then
        local local_hash=""
        local remote_hash=""
        
        # Download remote file temporarily to compute hash
        local temp_check_file=$(mktemp)
        if curl -s -o "$temp_check_file" "$SCRIPT_URL" && [[ -s "$temp_check_file" ]] && grep -q "todo - AI-Agent First TODO List Tracker" "$temp_check_file"; then
            # Verify we're not comparing the same file
            local script_realpath=$(realpath "$script_path" 2>/dev/null || echo "$script_path")
            local temp_realpath=$(realpath "$temp_check_file" 2>/dev/null || echo "$temp_check_file")
            
            # If somehow they're the same file, skip hash comparison and proceed with update
            if [[ "$script_realpath" == "$temp_realpath" ]] || [[ ! -f "$script_path" ]]; then
                rm -f "$temp_check_file"
                echo "‚ö†Ô∏è  Cannot compare hashes - proceeding with update to be safe"
            else
                # Compute local file hash (prefer sha256sum, fallback to md5 or shasum)
                if command -v sha256sum >/dev/null 2>&1; then
                    local_hash=$(sha256sum "$script_path" 2>/dev/null | cut -d' ' -f1)
                    remote_hash=$(sha256sum "$temp_check_file" 2>/dev/null | cut -d' ' -f1)
                elif command -v shasum >/dev/null 2>&1; then
                    local_hash=$(shasum -a 256 "$script_path" 2>/dev/null | cut -d' ' -f1)
                    remote_hash=$(shasum -a 256 "$temp_check_file" 2>/dev/null | cut -d' ' -f1)
                elif command -v md5sum >/dev/null 2>&1; then
                    local_hash=$(md5sum "$script_path" 2>/dev/null | cut -d' ' -f1)
                    remote_hash=$(md5sum "$temp_check_file" 2>/dev/null | cut -d' ' -f1)
                elif command -v md5 >/dev/null 2>&1; then
                    local_hash=$(md5 -q "$script_path" 2>/dev/null)
                    remote_hash=$(md5 -q "$temp_check_file" 2>/dev/null)
                fi
                
                rm -f "$temp_check_file"
                
                # If hashes couldn't be computed, proceed with update to be safe
                if [[ -z "$local_hash" ]] || [[ -z "$remote_hash" ]]; then
                    echo "‚ö†Ô∏è  Could not compute hashes - proceeding with update to be safe"
                fi
            fi
            
            # If hashes are available and match, files are identical - skip update
            # But only if we verified the files are different (checked above)
            if [[ "$script_realpath" != "$temp_realpath" ]] && [[ -n "$local_hash" ]] && [[ -n "$remote_hash" ]] && [[ "$local_hash" == "$remote_hash" ]]; then
                echo "‚úÖ todo.ai is already at the latest version ($VERSION)"
                echo "   Content hash matches - no update needed"
                echo "   Checking cursor rules..."
                # Still update cursor rules even if script is up to date
                if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
                    echo ""
                    echo "üîÑ Updating cursor rules..."
                    # Call init_cursor_rules directly since we're in the same script
                    init_cursor_rules
                fi
                return 0
            elif [[ "$script_realpath" != "$temp_realpath" ]] && [[ -n "$local_hash" ]] && [[ -n "$remote_hash" ]] && [[ "$local_hash" != "$remote_hash" ]]; then
                # Version matches but content differs - proceed with update
                echo "‚ö†Ô∏è  Version matches ($VERSION), but content differs"
                echo "   Updating to latest content..."
            else
                # Hash comparison not available or files are same - proceed with update to be safe
                if [[ "$script_realpath" == "$temp_realpath" ]]; then
                    echo "‚ö†Ô∏è  Cannot verify update - files appear identical"
                    echo "   Proceeding with update to ensure latest version..."
                elif [[ -z "$local_hash" ]] || [[ -z "$remote_hash" ]]; then
                    echo "‚ö†Ô∏è  Hash comparison not available - proceeding with update"
                    echo "   Content may have changed even though version matches"
                else
                    echo "‚ö†Ô∏è  Proceeding with update to ensure latest version"
                fi
            fi
        else
            rm -f "$temp_check_file"
            # Download failed - assume up to date if version matches
            echo "‚úÖ todo.ai is already at the latest version ($VERSION)"
            echo "   Checking cursor rules..."
            if command -v git >/dev/null 2>&1 && git rev-parse --git-dir >/dev/null 2>&1; then
                echo ""
                echo "üîÑ Updating cursor rules..."
                init_cursor_rules
            fi
            return 0
        fi
    fi
    
    # Download latest version
    local temp_file=$(mktemp)
    if curl -s -o "$temp_file" "$SCRIPT_URL"; then
        # Check if download was successful
        if [[ -s "$temp_file" ]] && grep -q "todo - AI-Agent First TODO List Tracker" "$temp_file"; then
            # Create versioned backup with timestamp
            local timestamp=$(date +"%Y%m%d%H%M%S")
            local current_version="$VERSION"
            local backup_file="$backups_dir/todo.ai.$timestamp"
            
            # Backup current version
            cp "$script_path" "$backup_file" 2>/dev/null || {
                echo "Warning: Failed to create backup, continuing with update..."
            }
            
            # Get new version before replacing
            local new_version=$(grep -i "VERSION=" "$temp_file" | head -1 | sed 's/.*VERSION="\([^"]*\)".*/\1/' || echo "unknown")
            
            # Make new version executable
            chmod +x "$temp_file"
            
            # CRITICAL FIX: Execute new version's code BEFORE replacing old version
            # This ensures new version's update logic, migrations, and cursor rules updates run
            echo ""
            echo "üîÑ Executing new version's update logic (v$new_version)..."
            local current_dir=$(pwd)
            local script_dir=$(dirname "$script_path")
            cd "$script_dir" 2>/dev/null || true
            
            # Execute new version's script directly (not via PATH or current directory)
            # This ensures the new script's code executes, not the old version
            # 1. Migrations (runs automatically at startup via run_migrations)
            # 2. Cursor rules update (runs automatically at startup via init_cursor_rules)
            # The new version's code will execute with its own logic, not the old version's
            # Suppress stdout (version info) but allow stderr (migration/cursor rules messages) through
            /bin/zsh "$temp_file" version >/dev/null || true
            
            # Now replace the old version with the new version
            mv "$temp_file" "$script_path"
            
            cd "$current_dir" 2>/dev/null || true
            
            echo "‚úÖ Updated todo.ai to version $new_version"
            if [[ -f "$backup_file" ]]; then
                echo "   Backup saved as: $(basename "$backup_file") (v$current_version)"
                echo "   Use './todo.ai rollback' to restore previous version"
            fi
            
            return 0
        else
            echo "Error: Downloaded file appears invalid"
            rm -f "$temp_file"
            return 1
        fi
    else
        echo "Error: Failed to download latest version"
        echo "Please check your internet connection or download manually from: $REPO_URL"
        rm -f "$temp_file"
        return 1
    fi
}




# ============================================================================
# Migration System
# ============================================================================

# Migration registry
# Format: "VERSION|MIGRATION_ID|DESCRIPTION|FUNCTION_NAME"
# Note: Old migrations (v1.3.5 section order fix, v1.6.0 cursor rules migration) have been removed
# to reduce code size. These migrations are no longer needed for current installations.
# If you need to run old migrations on a legacy install, see git history:
#   - v1.3.5 section order fix: commit bd028a2 and earlier
#   - v1.6.0 cursor rules migration: commit bd028a2 and earlier
declare -a MIGRATIONS=(
    # Add new migrations here in format: "VERSION|ID|DESCRIPTION|FUNCTION_NAME"
)

# Function to compare semantic versions
version_compare() {
    local version1="$1"
    local version2="$2"
    local operator="$3"
    
    # Convert versions to comparable format (1.3.5 -> 1003005)
    local v1_num=$(echo "$version1" | awk -F. '{printf "%d%03d%03d", $1, $2, $3}')
    local v2_num=$(echo "$version2" | awk -F. '{printf "%d%03d%03d", $1, $2, $3}')
    
    case "$operator" in
        ">=") [[ $v1_num -ge $v2_num ]] ;;
        ">")  [[ $v1_num -gt $v2_num ]] ;;
        "<=") [[ $v1_num -le $v2_num ]] ;;
        "<")  [[ $v1_num -lt $v2_num ]] ;;
        "==") [[ $v1_num -eq $v2_num ]] ;;
        *) return 1 ;;
    esac
}

# Function to run migrations
run_migrations() {
    local current_version="$VERSION"
    local migrations_dir="$(pwd)/.todo.ai/migrations"
    local lock_file="${migrations_dir}/.migrations_lock"
    
    # Lock to prevent concurrent execution
    if [[ -f "$lock_file" ]]; then
        # Another instance is running migrations, skip
        return 0
    fi
    
    # Create migrations directory if it doesn't exist
    mkdir -p "$migrations_dir" 2>/dev/null || return 1
    
    # Create lock file
    touch "$lock_file" 2>/dev/null || return 1
    
    # Find the highest already-executed migration version to determine "from" version
    local last_migrated_version=""
    if [[ -d "$migrations_dir" ]]; then
        # Find highest version from migration marker files
        for migration_file in "$migrations_dir"/v*_*.migrated; do
            if [[ -f "$migration_file" ]]; then
                local filename=$(basename "$migration_file")
                # Extract version (e.g., v1.3.5_section_order_fix.migrated -> 1.3.5)
                # Use sed for reliable extraction across shell versions
                local file_version=$(echo "$filename" | sed -n 's/^v\([0-9]\+\.[0-9]\+\.[0-9]\+\)_.*/\1/p')
                if [[ -n "$file_version" ]]; then
                    # Keep track of highest version
                    if [[ -z "$last_migrated_version" ]]; then
                        last_migrated_version="$file_version"
                    elif version_compare "$file_version" "$last_migrated_version" ">"; then
                        last_migrated_version="$file_version"
                    fi
                fi
            fi
        done
    fi
    
    # Collect pending migrations
    local pending_migrations=()
    local highest_pending_version=""
    for migration in "${MIGRATIONS[@]}"; do
        IFS='|' read -r target_version migration_id description function_name <<< "$migration"
        
        # Check if this migration applies to current or earlier version
        if version_compare "$current_version" "$target_version" ">="; then
            # Check if already executed
            local migration_file="${migrations_dir}/v${target_version}_${migration_id}.migrated"
            if [[ ! -f "$migration_file" ]]; then
                pending_migrations+=("$target_version|$migration_id|$description|$function_name")
                # Track highest pending migration version
                if [[ -z "$highest_pending_version" ]]; then
                    highest_pending_version="$target_version"
                elif version_compare "$target_version" "$highest_pending_version" ">"; then
                    highest_pending_version="$target_version"
                fi
            fi
        fi
    done
    
    # Display migration info if there are pending migrations
    if [[ ${#pending_migrations[@]} -gt 0 ]]; then
        # Determine from version: use last migrated version, or assume it's lower than first pending
        local from_version="$last_migrated_version"
        if [[ -z "$from_version" ]]; then
            # No migrations executed yet - find lowest pending version
            local lowest_pending_version=""
            for migration_data in "${pending_migrations[@]}"; do
                IFS='|' read -r target_version migration_id description function_name <<< "$migration_data"
                if [[ -z "$lowest_pending_version" ]]; then
                    lowest_pending_version="$target_version"
                elif version_compare "$target_version" "$lowest_pending_version" "<"; then
                    lowest_pending_version="$target_version"
                fi
            done
            # Estimate previous version (one patch version before lowest pending)
            # This is an approximation - actual previous version might be lower
            from_version="$lowest_pending_version"
        fi
        
        # Determine to version: use current version, or highest pending if higher
        local to_version="$current_version"
        if [[ -n "$highest_pending_version" ]] && version_compare "$highest_pending_version" "$current_version" ">"; then
            # This shouldn't happen in normal cases, but handle it
            to_version="$highest_pending_version"
        fi
        
        # Display migration info
        echo "üîÑ Running migrations: $from_version ‚Üí $to_version" >&2
    fi
    
    # Process each migration
    for migration in "${MIGRATIONS[@]}"; do
        IFS='|' read -r target_version migration_id description function_name <<< "$migration"
        
        # Check if this migration applies to current or earlier version
        if version_compare "$current_version" "$target_version" ">="; then
            # Check if already executed
            local migration_file="${migrations_dir}/v${target_version}_${migration_id}.migrated"
            if [[ ! -f "$migration_file" ]]; then
                # Run migration
                if "$function_name"; then
                    # Migration succeeded - output is handled by migration function
                    true
                else
                    # Migration failed - log but don't block
                    echo "‚ö†Ô∏è  Migration failed: $description" >&2
                fi
            fi
        fi
    done
    
    # Remove lock file
    rm -f "$lock_file" 2>/dev/null || true
}

# ============================================================================
# Bug Reporting System
# ============================================================================

# Bug reporting configuration
BUG_REPORT_ENABLED="${BUG_REPORT_ENABLED:-true}"
BUG_REPORT_THRESHOLD="${BUG_REPORT_THRESHOLD:-75}"  # Similarity threshold (%)

# Get GitHub repository URL (sanitized for private repos)
get_bug_report_repo() {
    # Bug reports are always for todo.ai itself, not the repository it's installed in
    # Always return the todo.ai repository URL
    echo "https://github.com/fxstein/todo.ai"
}

# Check if repository is private
is_private_repo() {
    local repo_url="$1"
    if [[ -z "$repo_url" ]]; then
        return 1
    fi
    
    # Check if we can access repository metadata (basic check)
    if command -v gh >/dev/null 2>&1; then
        local repo_info=$(gh repo view "$repo_url" --json isPrivate 2>/dev/null)
        if [[ -n "$repo_info" ]]; then
            local is_private=$(echo "$repo_info" | grep -o '"isPrivate":[^,}]*' | cut -d: -f2)
            if [[ "$is_private" == "true" ]]; then
                return 0
            fi
        fi
    fi
    
    # Default: assume public if we can't determine
    return 1
}

# Collect error context
collect_error_context() {
    local error_message="$1"
    local error_context="$2"
    local command="$3"
    
    # Collect system information
    local os_info=$(uname -srm 2>/dev/null || echo "Unknown")
    local shell_info="$SHELL $(echo $SHELL | xargs -I{} {} --version 2>/dev/null | head -1 || echo '')"
    local version_info="$VERSION"
    
    # Collect git information
    local git_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "N/A")
    local git_status=$(git status --porcelain 2>/dev/null | wc -l | tr -d ' ')
    local git_dirty="clean"
    if [[ "$git_status" != "0" ]]; then
        git_dirty="dirty ($git_status files changed)"
    fi
    local git_commit=$(git rev-parse --short HEAD 2>/dev/null || echo "N/A")
    local git_info="Branch: $git_branch | Status: $git_dirty | Commit: $git_commit"
    
    # Collect TODO.md state
    local todo_count=0
    local todo_mode="unknown"
    local todo_coordination="unknown"
    if [[ -f "$TODO_FILE" ]]; then
        todo_count=$(grep -c "^- \[ \]" "$TODO_FILE" 2>/dev/null || echo "0")
    fi
    if [[ -f ".todo.ai/.todo.ai.config.yml" ]]; then
        todo_mode=$(grep "^mode:" ".todo.ai/.todo.ai.config.yml" 2>/dev/null | awk '{print $2}' || echo "single-user")
        todo_coordination=$(grep "^  type:" ".todo.ai/.todo.ai.config.yml" 2>/dev/null | awk '{print $2}' || echo "none")
    else
        todo_mode="single-user"
        todo_coordination="none"
    fi
    local todo_info="Active tasks: $todo_count | Mode: $todo_mode | Coordination: $todo_coordination"
    
    # Collect environment info
    local env_term="${TERM:-unknown}"
    local env_editor="${EDITOR:-unknown}"
    local env_lang="${LANG:-unknown}"
    local env_info="TERM=$env_term | EDITOR=$env_editor | LANG=$env_lang"
    
    # Collect recent commands from log
    local recent_commands=""
    if [[ -f "$LOG_FILE" ]]; then
        recent_commands=$(grep -v "^#" "$LOG_FILE" 2>/dev/null | grep "COMMAND:" | head -n 5 | sed 's/.*COMMAND: //' || echo "")
    fi
    
    # Collect recent logs (first 50 log entries from top of file, skipping header lines)
    # NOTE: Log file is sorted in descending order (newest entries at the top)
    # So we use head with grep to skip header lines (# comments) and get the most recent entries
    local recent_logs=""
    if [[ -f "$LOG_FILE" ]]; then
        recent_logs=$(grep -v "^#" "$LOG_FILE" 2>/dev/null | head -n 50 || echo "")
    fi
    
    # Sanitize logs (remove sensitive info)
    recent_logs=$(echo "$recent_logs" | sed 's/password[=:][^[:space:]]*/password=***/gi' || echo "$recent_logs")
    recent_logs=$(echo "$recent_logs" | sed 's/token[=:][^[:space:]]*/token=***/gi' || echo "$recent_logs")
    recent_logs=$(echo "$recent_logs" | sed 's/api[_-]key[=:][^[:space:]]*/api-key=***/gi' || echo "$recent_logs")
    
    # Sanitize commands (remove sensitive info)
    recent_commands=$(echo "$recent_commands" | sed 's/password[=:][^[:space:]]*/password=***/gi' || echo "$recent_commands")
    recent_commands=$(echo "$recent_commands" | sed 's/token[=:][^[:space:]]*/token=***/gi' || echo "$recent_commands")
    recent_commands=$(echo "$recent_commands" | sed 's/api[_-]key[=:][^[:space:]]*/api-key=***/gi' || echo "$recent_commands")
    
    # Collect repository info (sanitized for private repos)
    local repo_url=$(get_bug_report_repo)
    local repo_info=""
    if [[ -n "$repo_url" ]] && ! is_private_repo "$repo_url"; then
        repo_info="Git Repository: $repo_url"
    elif [[ -n "$repo_url" ]]; then
        # Private repo - don't include repo identifier
        repo_info="Git Repository: [private repository]"
    fi
    
    # Build context object (we'll use this in generate_bug_report)
    # Use ###FIELD_SEP### as field separator to avoid conflicts with log content which contains pipes
    echo "ERROR_MESSAGE:$error_message###FIELD_SEP###ERROR_CONTEXT:$error_context###FIELD_SEP###COMMAND:$command###FIELD_SEP###OS:$os_info###FIELD_SEP###SHELL:$shell_info###FIELD_SEP###VERSION:$version_info###FIELD_SEP###GIT:$git_info###FIELD_SEP###TODO:$todo_info###FIELD_SEP###ENV:$env_info###FIELD_SEP###RECENT_COMMANDS:$recent_commands###FIELD_SEP###LOGS:$recent_logs###FIELD_SEP###REPO:$repo_info"
}

# Collect logs for bug report
collect_logs() {
    local max_lines="${1:-50}"
    local log_content=""
    
    # Collect from .todo.ai/.todo.ai.log
    # NOTE: Log file is sorted in descending order (newest entries at the top)
    # So we use head with grep to skip header lines (# comments) and get the most recent entries
    if [[ -f "$LOG_FILE" ]]; then
        log_content=$(grep -v "^#" "$LOG_FILE" 2>/dev/null | head -n "$max_lines" || echo "")
    fi
    
    # Sanitize sensitive information
    log_content=$(echo "$log_content" | sed 's/password[=:][^[:space:]]*/password=***/gi' || echo "$log_content")
    log_content=$(echo "$log_content" | sed 's/token[=:][^[:space:]]*/token=***/gi' || echo "$log_content")
    log_content=$(echo "$log_content" | sed 's/api[_-]key[=:][^[:space:]]*/api-key=***/gi' || echo "$log_content")
    
    echo "$log_content"
}

# Categorize error and suggest labels
categorize_error() {
    local error_message="$1"
    local error_context="$2"
    local labels="bug"  # Always include 'bug' label
    
    # Convert to lowercase for pattern matching
    local error_lower=$(echo "$error_message $error_context" | tr '[:upper:]' '[:lower:]')
    
    # Error type labels
    if echo "$error_lower" | grep -qE 'segfault|segmentation fault|core dump|signal 11'; then
        labels="$labels,crash"
    elif echo "$error_lower" | grep -qE 'timeout|too slow|performance|taking too long'; then
        labels="$labels,performance"
    elif echo "$error_lower" | grep -qE 'data loss|file corrupt|lost|missing data|cannot find'; then
        labels="$labels,data-loss"
    elif echo "$error_lower" | grep -qE 'github|api|coordination|gh cli|issue.*not found'; then
        labels="$labels,coordination"
    fi
    
    # OS-specific labels
    if uname -s | grep -qi 'darwin'; then
        labels="$labels,macos"
    elif uname -s | grep -qi 'linux'; then
        if [[ -n "$WSL_DISTRO_NAME" ]] || grep -qi microsoft /proc/version 2>/dev/null; then
            labels="$labels,wsl"
        else
            labels="$labels,linux"
        fi
    fi
    
    # Shell-specific labels
    if echo "$SHELL" | grep -qi 'zsh'; then
        labels="$labels,zsh"
    elif echo "$SHELL" | grep -qi 'bash'; then
        labels="$labels,bash"
    fi
    
    echo "$labels"
}

# Generate bug report template
generate_bug_report() {
    local error_message="$1"
    local error_context="$2"
    local command="${3:-unknown}"
    
    # Collect context
    local context=$(collect_error_context "$error_message" "$error_context" "$command")
    
    # Parse context (using ###FIELD_SEP### as field separator to avoid conflicts with log pipes)
    local os_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^OS:/) {print substr($i, 4); exit}}')
    local shell_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^SHELL:/) {print substr($i, 7); exit}}')
    local version_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^VERSION:/) {print substr($i, 9); exit}}')
    local repo_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^REPO:/) {print substr($i, 6); exit}}')
    local git_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^GIT:/) {print substr($i, 5); exit}}')
    local todo_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^TODO:/) {print substr($i, 6); exit}}')
    local env_info=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^ENV:/) {print substr($i, 5); exit}}')
    local recent_commands=$(echo "$context" | awk -F'###FIELD_SEP###' '{for(i=1;i<=NF;i++) if($i ~ /^RECENT_COMMANDS:/) {print substr($i, 17); exit}}')
    
    # Collect logs directly to preserve newlines (don't parse from context string)
    # Use a temporary file to preserve all newlines correctly
    local temp_logs=$(mktemp)
    collect_logs 50 > "$temp_logs"
    local logs=$(cat "$temp_logs")
    rm -f "$temp_logs"
    
    # Format shell version (clean up)
    local shell_version=$(echo "$shell_info" | awk '{print $NF}' | head -1)
    if [[ -z "$shell_version" ]]; then
        shell_version="unknown"
    fi
    
    # Get current date/time
    local current_date=$(date '+%Y-%m-%d %H:%M:%S')
    
    # Get todo.ai path for bug report (use detected path)
    local todo_ai_path=$(get_todo_ai_path_for_rules 2>/dev/null || echo "./todo.ai")
    
    # Build bug report with GitHub callout blocks and better formatting
    local bug_report="## üêõ Bug Report

> [!WARNING]
> **Error Occurred**: $current_date

---

### Error Description

\`\`\`text
$error_message
\`\`\`

### Command Executed

\`\`\`bash
$todo_ai_path $command
\`\`\`

### Error Context

\`\`\`text
$error_context
\`\`\`

---

### System Information

> [!NOTE]
> Environment details collected automatically

| Component | Details |
|-----------|---------|
| **OS** | $os_info |
| **Shell** | $shell_version |
| **Version** | $version_info |"
    
    # Add repo info if available
    if [[ -n "$repo_info" ]]; then
        bug_report="$bug_report
| **Repository** | $repo_info |"
    fi
    
    bug_report="$bug_report

---

<details>
<summary><strong>üìä Additional Context</strong></summary>

#### Git Status
\`\`\`
$git_info
\`\`\`

#### TODO.md State
\`\`\`
$todo_info
\`\`\`

#### Environment Variables
\`\`\`
$env_info
\`\`\`

</details>

---

<details>
<summary><strong>üìú Recent Commands</strong> (last 5)</summary>

\`\`\`bash
$recent_commands
\`\`\`

</details>

---

<details>
<summary><strong>üìã Recent Logs</strong> (last 50 lines)</summary>

\`\`\`
$logs
\`\`\`

</details>

---

### Additional Information

*Add any other relevant details here*

---

<sub>ü§ñ Reported automatically by todo.ai v$version_info</sub>"
    
    echo "$bug_report"
}

# Calculate similarity between two strings (simple word-based)
calculate_similarity() {
    local text1="$1"
    local text2="$2"
    
    # Convert to lowercase and extract words
    local words1=$(echo "$text1" | tr '[:upper:]' '[:lower:]' | tr -s '[:space:]' '\n' | sort -u)
    local words2=$(echo "$text2" | tr '[:upper:]' '[:lower:]' | tr -s '[:space:]' '\n' | sort -u)
    
    # Count common words and total unique words
    local common_words=$(comm -12 <(echo "$words1") <(echo "$words2") | wc -l | tr -d ' ')
    local total_unique=$(comm -3 <(echo "$words1") <(echo "$words2") | wc -l | tr -d ' ')
    local total_words=$(comm <(echo "$words1") <(echo "$words2") | wc -l | tr -d ' ')
    
    # Calculate similarity percentage (simple Jaccard-like)
    if [[ $total_unique -eq 0 ]] && [[ $common_words -gt 0 ]]; then
        echo "100"
        return
    fi
    
    # Calculate similarity without bc (fallback for systems without bc)
    if command -v bc >/dev/null 2>&1; then
        local similarity=$(echo "scale=0; $common_words * 100 / ($total_unique + $common_words)" | bc 2>/dev/null || echo "0")
    else
        # Simple integer calculation fallback
        local total=$((total_unique + common_words))
        if [[ $total -gt 0 ]]; then
            local similarity=$((common_words * 100 / total))
        else
            local similarity=0
        fi
    fi
    echo "$similarity"
}

# Check for duplicate issues
check_for_duplicate_issues() {
    local title="$1"
    local body="$2"
    local repo_url="$3"
    
    if [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
                echo ""
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo ""
        return 1
    fi
    
    # Search for issues with similar titles (extract keywords from title)
    local keywords=$(echo "$title" | tr '[:upper:]' '[:lower:]' | grep -oE '[a-z]+' | head -5 | tr '\n' ' ' | sed 's/ $//')
    
    if [[ -z "$keywords" ]]; then
        echo ""
        return 1
    fi
    
    # Search for issues (limit to last 30 days)
    # Note: Don't include body in initial search as it may contain control characters that break JSON parsing
    local issues_json=$(gh issue list --repo "$repo_url" --search "in:title $keywords" --limit 10 --json number,title,state,createdAt 2>/dev/null || echo "[]")
    
    if [[ -z "$issues_json" ]] || [[ "$issues_json" == "[]" ]]; then
        echo ""
        return 1
    fi
    
    # Parse issues and check similarity
    local duplicates=""
    
    # Use jq if available, otherwise fall back to basic parsing
    if command -v jq >/dev/null 2>&1; then
        # Use jq for proper JSON parsing
        local issues_count=$(echo "$issues_json" | jq '. | length' 2>/dev/null || echo "0")
        
        for ((i=0; i<issues_count; i++)); do
            local issue_number=$(echo "$issues_json" | jq -r ".[$i].number" 2>/dev/null || echo "")
            local issue_title=$(echo "$issues_json" | jq -r ".[$i].title" 2>/dev/null || echo "")
            
            if [[ -z "$issue_number" ]] || [[ -z "$issue_title" ]] || [[ "$issue_number" == "null" ]] || [[ "$issue_title" == "null" ]]; then
                continue
            fi
            
            # Normalize titles for comparison (strip "Bug: " prefix from issue title)
            local normalized_issue_title=$(echo "$issue_title" | sed 's/^Bug: *//')
            local normalized_title="$title"
            
            # Calculate similarity for title
            local title_similarity=$(calculate_similarity "$normalized_title" "$normalized_issue_title")
            
            # Use title similarity (body comparison skipped to avoid JSON parsing issues)
            local max_similarity=$title_similarity
            
            # If similarity >= threshold, consider it a duplicate
            if [[ $max_similarity -ge $BUG_REPORT_THRESHOLD ]]; then
                if [[ -z "$duplicates" ]]; then
                    duplicates="$issue_number|$issue_title|$max_similarity"
                else
                    duplicates="$duplicates\n$issue_number|$issue_title|$max_similarity"
                fi
            fi
        done
    else
        # Fallback to basic parsing (less reliable)
        local issues_count=$(echo "$issues_json" | grep -o '"number"' | wc -l | tr -d ' ')
        
        for ((i=0; i<issues_count; i++)); do
            # Try to extract using awk (more reliable than grep+cut)
            local issue_data=$(echo "$issues_json" | awk -v i="$i" 'BEGIN{RS="},? ?{";FS=","} NR==i+1 {
                for(j=1;j<=NF;j++) {
                    if($j ~ /"number":/) {
                        gsub(/.*"number": ?/, "", $j)
                        gsub(/[^0-9].*/, "", $j)
                        print $j
                        break
                    }
                }
            }' | head -1)
            
            # Simple extraction - this is less reliable but better than before
            local issue_number=$(echo "$issues_json" | awk -v i="$i" '{
                gsub(/.*"number": ?/, "", $0)
                match($0, /[0-9]+/)
                if(RSTART>0) print substr($0, RSTART, RLENGTH)
            }' | sed -n "$((i+1))p")
            
            if [[ -z "$issue_number" ]] || ! [[ "$issue_number" =~ ^[0-9]+$ ]]; then
                continue
            fi
            
            # Extract title (basic approach - get text between "title":" and next "
            local issue_title=$(echo "$issues_json" | grep -o "\"title\":\"[^\"]*\"" | sed -n "$((i+1))p" | sed 's/"title":"//' | sed 's/"$//')
            
            if [[ -z "$issue_title" ]]; then
                continue
            fi
            
            # Normalize titles for comparison (strip "Bug: " prefix from issue title)
            local normalized_issue_title=$(echo "$issue_title" | sed 's/^Bug: *//')
            local normalized_title="$title"
            
            # Calculate similarity for title
            local title_similarity=$(calculate_similarity "$normalized_title" "$normalized_issue_title")
            
            # Use title similarity only (body parsing is too complex without jq)
            local max_similarity=$title_similarity
            
            # If similarity >= threshold, consider it a duplicate
            if [[ $max_similarity -ge $BUG_REPORT_THRESHOLD ]]; then
                if [[ -z "$duplicates" ]]; then
                    duplicates="$issue_number|$issue_title|$max_similarity"
                else
                    duplicates="$duplicates\n$issue_number|$issue_title|$max_similarity"
                fi
            fi
        done
    fi
    
    if [[ -n "$duplicates" ]]; then
        echo -e "$duplicates"
            return 0
        else
        echo ""
            return 1
        fi
}

# Create new GitHub issue
create_new_issue() {
    local title="$1"
    local body="$2"
    local repo_url="$3"
    local labels="${4:-bug}"
    
    if [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        echo "Error: GitHub CLI not available or repository not configured"
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo "Error: GitHub CLI not authenticated. Run 'gh auth login' first"
        return 1
    fi
    
    # Create temporary file for body
    local temp_body=$(mktemp)
    echo "$body" > "$temp_body"
    
    # Add auto-reported label if not already present
    if [[ "$labels" != *"auto-reported"* ]]; then
        labels="$labels,auto-reported"
    fi
    
    # Create issue with suggested labels
    echo "Creating issue with labels: $labels"
    if gh issue create --repo "$repo_url" --title "$title" --body-file "$temp_body" --label "$labels" 2>&1 | tee /tmp/gh-output; then
        echo "‚úÖ Bug report created successfully"
        rm -f "$temp_body"
        return 0
    else
        # Fallback: try with just bug label if specific labels don't exist
        echo "‚ö†Ô∏è  Some labels not available, retrying with bug label only..."
        if gh issue create --repo "$repo_url" --title "$title" --body-file "$temp_body" --label "bug" >/dev/null 2>&1; then
            echo "‚úÖ Bug report created successfully (with basic labels)"
            rm -f "$temp_body"
            return 0
        else
            echo "Error: Failed to create issue"
            rm -f "$temp_body"
            return 1
        fi
    fi
}

# Reply to existing issue
reply_to_existing_issue() {
    local issue_number="$1"
    local body="$2"
    local repo_url="$3"
    
    if [[ -z "$repo_url" ]] || ! command -v gh >/dev/null 2>&1; then
        echo "Error: GitHub CLI not available or repository not configured"
        return 1
    fi
    
    # Check GitHub CLI authentication
    if ! gh auth status >/dev/null 2>&1; then
        echo "Error: GitHub CLI not authenticated. Run 'gh auth login' first"
        return 1
    fi
    
    # Create "me too" message
    local me_too_message="## Me Too - Same Issue Encountered

**Version**: $VERSION
**Date**: $(date '+%Y-%m-%d %H:%M:%S')
**OS**: $(uname -srm 2>/dev/null || echo 'Unknown')

I'm experiencing the same error. Here's my context:

$body

---
*Reported automatically by todo.ai*"
    
    # Create temporary file for comment
    local temp_comment=$(mktemp)
    echo "$me_too_message" > "$temp_comment"
    
    # Add comment to issue
    if gh issue comment "$issue_number" --repo "$repo_url" --body-file "$temp_comment" >/dev/null 2>&1; then
        echo "‚úÖ Added 'me too' comment to issue #$issue_number"
        rm -f "$temp_comment"
        return 0
    else
        echo "Error: Failed to add comment to issue"
        rm -f "$temp_comment"
        return 1
    fi
}

# Handle duplicate detection with user confirmation
handle_duplicate_detection() {
    local title="$1"
    local body="$2"
    local repo_url="$3"
    local labels="${4:-bug}"
    
    # Check for duplicates
    local duplicates=$(check_for_duplicate_issues "$title" "$body" "$repo_url")
    
    if [[ -n "$duplicates" ]]; then
        echo ""
        echo "Similar issues found:"
        echo ""
        
        # Display duplicates and collect issue numbers
        local count=1
        local issue_numbers=()
        while IFS='|' read -r issue_num issue_title similarity; do
            if [[ -n "$issue_num" ]]; then
                echo "$count) Issue #$issue_num: $issue_title (similarity: ${similarity}%)"
                issue_numbers+=("$issue_num")
                count=$((count + 1))
            fi
        done <<< "$duplicates"
        
        echo ""
        printf "Would you like to add a 'me too' comment to an existing issue? (y/N) "
        read -r reply
        
        if [[ "$reply" =~ ^[Yy]$ ]]; then
            # Ask which issue
            echo ""
            printf "Enter issue number to reply to: "
            read -r selected_num
            
            if [[ -n "$selected_num" ]] && [[ "$selected_num" =~ ^[0-9]+$ ]]; then
                if reply_to_existing_issue "$selected_num" "$body" "$repo_url"; then
                    return 0
                else
                    echo "Error: Failed to add comment. Bug report cancelled."
                    return 1
                fi
            else
                echo "Invalid issue number"
                return 1
            fi
        else
            printf "Create a new issue instead? (y/N) "
            read -r reply
            if [[ "$reply" =~ ^[Yy]$ ]]; then
                create_new_issue "$title" "$body" "$repo_url" "$labels"
            else
                echo "Bug report cancelled"
                return 0
            fi
        fi
    else
        # No duplicates, create new issue directly
        create_new_issue "$title" "$body" "$repo_url" "$labels"
    fi
}

# Main bug reporting entry point - ALWAYS requires user confirmation
suggest_bug_report() {
    local error_message="$1"
    local error_context="$2"
    local command="${3:-unknown}"
    
    # Check if bug reporting is enabled
    if [[ "$BUG_REPORT_ENABLED" != "true" ]]; then
        return 0
    fi
    
    # Get repository URL
    local repo_url=$(get_bug_report_repo)
    if [[ -z "$repo_url" ]]; then
        echo "‚ö†Ô∏è  Cannot report bug: No GitHub repository configured"
        return 1
    fi
    
    # Generate bug report
    local bug_report=$(generate_bug_report "$error_message" "$error_context" "$command")
    
    # Categorize error and get suggested labels
    local labels=$(categorize_error "$error_message" "$error_context")
    
    # Extract title from error message (first line, max 100 chars)
    local title="[Bug]: $(echo "$error_message" | head -1 | cut -c1-90)"
    
    # Detect if running in AI agent context
    local is_ai_agent=false
    if [[ -n "$CURSOR_AI" ]] || [[ -n "$AI_AGENT" ]] || [[ -n "$GITHUB_ACTIONS" ]]; then
        is_ai_agent=true
    fi
    
    # Show error and preview
    echo ""
    echo "‚ö†Ô∏è  An error occurred: $error_message"
    echo ""
    
    if [[ "$is_ai_agent" == "true" ]]; then
        echo "ü§ñ AI Agent detected - Bug report will be submitted automatically"
        echo ""
        echo "Preview of bug report:"
        echo "---"
        # Show condensed preview for agents
        echo "$bug_report" | head -30
        echo "..."
        echo "---"
        echo ""
        echo "üìã Suggested labels: $labels"
        echo ""
        echo "‚è≥ Auto-submitting in 2 seconds..."
        sleep 2
        echo "‚úì Proceeding with bug report submission"
        
        # Proceed automatically - no prompt needed
        handle_duplicate_detection "$title" "$bug_report" "$repo_url" "$labels"
    else
        # Human user - show full preview and ask for confirmation
        echo "Would you like to report this bug to GitHub Issues?"
        echo ""
        echo "Preview of bug report:"
        echo "---"
        # Show header sections
        echo "$bug_report" | head -40
        echo ""
        echo "... (additional context sections collapsed) ..."
        echo ""
        echo "---"
        echo ""
        echo "üìã Suggested labels: $labels"
        echo ""
        
        # Always require confirmation for humans
        printf "Report this bug? (y/N) "
        read -r reply
        
        if [[ ! "$reply" =~ ^[Yy]$ ]]; then
            echo "Bug report cancelled by user"
            return 0
        fi
        
        # User confirmed - proceed with duplicate check and reporting
        handle_duplicate_detection "$title" "$bug_report" "$repo_url" "$labels"
    fi
}

# Command handler for manual bug reporting
report_bug() {
    local error_description="$1"
    local error_context="${2:-}"
    local command="${3:-}"
    
    if [[ -z "$error_description" ]]; then
        local todo_ai_path=$(get_todo_ai_path_for_rules 2>/dev/null || echo "./todo.ai")
        echo "Error: Please provide an error description"
        echo "Usage: $todo_ai_path report-bug \"Error description\" [error context] [command]"
        return 1
    fi
    
    suggest_bug_report "$error_description" "$error_context" "$command"
}

# Function to uninstall todo.ai
uninstall_tool() {
    local remove_data=false
    local remove_rules=false
    local force=false
    
    # Parse options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --remove-data|--data)
                remove_data=true
                shift
                ;;
            --remove-rules|--rules)
                remove_rules=true
                shift
                ;;
            --all)
                remove_data=true
                remove_rules=true
                shift
                ;;
            --force|-f)
                force=true
                shift
                ;;
            *)
                echo "Error: Unknown option '$1'"
                echo "Usage: ./todo.ai uninstall [--remove-data] [--remove-rules] [--all] [--force]"
                return 1
                ;;
        esac
    done
    
    # Get script path
    local script_path
    script_path=$(get_script_path) || {
        echo "‚ö†Ô∏è  Cannot locate todo.ai script"
        echo "   It may already be uninstalled."
        return 1
    }
    
    # Detect .todo.ai/ directory (in current working directory)
    local todo_ai_dir="$(pwd)/.todo.ai"
    local has_data_dir=false
    if [[ -d "$todo_ai_dir" ]]; then
        has_data_dir=true
    fi
    
    # Detect Cursor rules created by todo.ai
    local rules_dir="$(pwd)/.cursor/rules"
    local todo_ai_rules=()
    if [[ -d "$rules_dir" ]]; then
        # Find all todo.ai-*.mdc files
        for rule_file in "$rules_dir"/todo.ai-*.mdc; do
            if [[ -f "$rule_file" ]]; then
                todo_ai_rules+=("$rule_file")
            fi
        done
    fi
    
    # Build what will be removed list
    echo ""
    echo "üóëÔ∏è  Uninstalling todo.ai"
    echo ""
    echo "The following will be removed:"
    
    local will_remove_script=true
    local will_remove_data=false
    local will_remove_rules=false
    
    if [[ -f "$script_path" ]]; then
        echo "  ‚úó Script: $script_path"
    else
        will_remove_script=false
    fi
    
    if [[ "$remove_data" == true ]] && [[ "$has_data_dir" == true ]]; then
        echo "  ‚úó Data directory: $todo_ai_dir"
        will_remove_data=true
        echo "     ‚ö†Ô∏è  Warning: This will remove your TODO data (.todo.ai/ directory)"
        echo "     ‚ö†Ô∏è  Your TODO.md file will remain untouched"
    elif [[ "$has_data_dir" == true ]]; then
        echo "  ‚úì Data directory: $todo_ai_dir (preserved - use --remove-data to remove)"
    fi
    
    if [[ "$remove_rules" == true ]] && [[ ${#todo_ai_rules[@]} -gt 0 ]]; then
        echo "  ‚úó Cursor rules:"
        for rule_file in "${todo_ai_rules[@]}"; do
            echo "      - $(basename "$rule_file")"
        done
        will_remove_rules=true
    elif [[ ${#todo_ai_rules[@]} -gt 0 ]]; then
        echo "  ‚úì Cursor rules: ${#todo_ai_rules[@]} file(s) (preserved - use --remove-rules to remove)"
    fi
    
    # Safety check: ensure we have something to remove
    if [[ "$will_remove_script" == false ]] && [[ "$will_remove_data" == false ]] && [[ "$will_remove_rules" == false ]]; then
        echo ""
        echo "‚úÖ Nothing to remove. Script not found or already uninstalled."
        return 0
    fi
    
    echo ""
    
    # Confirmation (unless --force)
    if [[ "$force" != true ]]; then
        printf "Proceed with uninstall? (y/N) "
        read -r reply
        if [[ ! "$reply" =~ ^[Yy]$ ]]; then
            echo "Uninstall cancelled"
            return 0
        fi
    fi
    
    # Remove script
    if [[ "$will_remove_script" == true ]]; then
        if rm -f "$script_path" 2>/dev/null; then
            echo "‚úÖ Removed script: $script_path"
        else
            echo "‚ö†Ô∏è  Error: Could not remove script: $script_path"
            echo "   You may need to remove it manually"
            return 1
        fi
    fi
    
    # Remove data directory
    if [[ "$will_remove_data" == true ]]; then
        if rm -rf "$todo_ai_dir" 2>/dev/null; then
            echo "‚úÖ Removed data directory: $todo_ai_dir"
        else
            echo "‚ö†Ô∏è  Error: Could not remove data directory: $todo_ai_dir"
            echo "   You may need to remove it manually"
        fi
    fi
    
    # Remove Cursor rules
    if [[ "$will_remove_rules" == true ]]; then
        local rules_removed=0
        for rule_file in "${todo_ai_rules[@]}"; do
            if rm -f "$rule_file" 2>/dev/null; then
                rules_removed=$((rules_removed + 1))
            fi
        done
        if [[ $rules_removed -gt 0 ]]; then
            echo "‚úÖ Removed $rules_removed Cursor rule(s)"
        else
            echo "‚ö†Ô∏è  Error: Could not remove Cursor rules"
            echo "   You may need to remove them manually from $rules_dir"
        fi
    fi
    
    echo ""
    echo "‚úÖ Uninstall complete!"
    
    return 0
}

# Migration: Fix section order in TODO.md
# Old migration functions removed to reduce code size (~363 lines saved)
# Legacy migrations (v1.3.5, v1.6.0) are no longer needed for current installations
# For old installations needing these migrations, see git history commit bd028a2 and earlier

# Placeholder for future migration functions
# Example format:
# migrate_example_v2_2_0() {
#     local migration_id="example_fix"
#     local migrations_dir="$(pwd)/.todo.ai/migrations"
#     local migration_file="${migrations_dir}/v2.2.0_${migration_id}.migrated"
#     
#     if [[ -f "$migration_file" ]]; then
#         return 0
#     fi
#     
#     # ... migration logic here ...
#     
#     mkdir -p "$migrations_dir" 2>/dev/null || return 1
#     touch "$migration_file" 2>/dev/null || return 1
#     return 0
# }

# End of migration functions placeholder

# ============================================================================
# Script Initialization
# ============================================================================

# Initialize log file
init_log_file

# Initialize TODO file
init_todo_file

# Run migrations (after initialization, before main logic)
run_migrations

# Initialize Cursor rules if needed (check on every run, add if missing)
init_cursor_rules

# Display current operating mode (unless it's a command that doesn't need it)
# Skip for internal operations and help/version commands
if [[ "${1:-}" != "version" && "${1:-}" != "--version" && "${1:-}" != "-v" && \
      "${1:-}" != "--help" && "${1:-}" != "help" && "${1:-}" != "-h" && \
      "${1:-}" != "--info" ]]; then
    local current_mode=$(get_numbering_mode)
    local coord_type=$(get_config_value "coordination.type" "none")
    
    if [[ "$current_mode" == "enhanced" ]] || [[ "$current_mode" == "single-user" ]]; then
        # Show mode and coordinator if coordination is configured
        if [[ "$coord_type" != "none" ]] && [[ -n "$coord_type" ]]; then
            case "$coord_type" in
                "github-issues")
                    local issue_num=$(get_config_value "coordination.issue_number" "")
                    if [[ -n "$issue_num" ]]; then
                        echo "üìã Mode: $current_mode | Coordinator: GitHub Issues (#$issue_num)" >&2
                    else
                        echo "üìã Mode: $current_mode | Coordinator: GitHub Issues (not configured)" >&2
                    fi
                    ;;
                "counterapi")
                    local namespace=$(get_config_value "coordination.namespace" "")
                    if [[ -n "$namespace" ]]; then
                        echo "üìã Mode: $current_mode | Coordinator: CounterAPI ($namespace)" >&2
                    else
                        echo "üìã Mode: $current_mode | Coordinator: CounterAPI (not configured)" >&2
                    fi
                    ;;
                *)
                    echo "üìã Mode: $current_mode | Coordinator: $coord_type" >&2
                    ;;
            esac
        else
            # No coordination configured
            if [[ "$current_mode" == "enhanced" ]]; then
                echo "üìã Mode: $current_mode | Coordinator: none (fallback)" >&2
            else
                # Simple mode display for single-user without coordination
                echo "üìã Mode: $current_mode" >&2
            fi
        fi
    else
        # Simple mode display for other modes
        echo "üìã Mode: $current_mode" >&2
    fi
fi

# Main script logic
case "${1:-}" in
    "add")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "add" "$@"; then
            exit 1
        fi
        add_todo "$1" "$2"
        ;;
    "add-subtask")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "add-subtask" "$@"; then
            exit 1
        fi
        add_subtask "$1" "$2" "$3"
        ;;
    "list")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "list" "$@"; then
            exit 1
        fi
        list_todos "$@"
        ;;
    "complete")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "complete" "$@"; then
            exit 1
        fi
        complete_todo "$@"
        ;;
    "undo")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "undo" "$@"; then
            exit 1
        fi
        undo_todo "$1"
        ;;
    "modify")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "modify" "$@"; then
            exit 1
        fi
        modify_todo "$1" "$2" "$3"
        ;;
    "archive")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "archive" "$@"; then
            exit 1
        fi
        # Parse task IDs and reason flag
        local task_ids=()
        local reason_arg=""
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --reason)
                    reason_arg="--reason"
                    reason_value="$2"
                    shift 2
                    ;;
                *)
                    task_ids+=("$1")
                    shift
                    ;;
            esac
        done
        # Archive each task with reason if provided
        for task_id in "${task_ids[@]}"; do
            if [[ -n "$reason_arg" ]]; then
                archive_task "$task_id" --reason "$reason_value"
            else
                archive_task "$task_id"
            fi
        done
        ;;
    "delete")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "delete" "$@"; then
            exit 1
        fi
        delete_task "$@"
        ;;
    "relate")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "relate" "$@"; then
            exit 1
        fi
        relate_task "$@"
        ;;
    "note")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "note" "$@"; then
            exit 1
        fi
        add_note "$1" "$2"
        ;;
    "delete-note")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "delete-note" "$@"; then
            exit 1
        fi
        delete_note "$1"
        ;;
    "update-note")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "update-note" "$@"; then
            exit 1
        fi
        update_note "$1" "$2"
        ;;
    "show")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "show" "$@"; then
            exit 1
        fi
        show_task "$1"
        ;;
    "restore")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "restore" "$@"; then
            exit 1
        fi
        restore_task "$1"
        ;;
    "--lint")
        lint_todo
        ;;
    "--reformat")
        if [[ "$2" == "--dry-run" ]]; then
            reformat_todo "--dry-run"
        else
            reformat_todo
        fi
        ;;
    "resolve-conflicts")
        shift
        if [[ "$1" == "--dry-run" ]]; then
            resolve_conflicts "--dry-run"
        else
            resolve_conflicts
        fi
        ;;
    "edit")
        edit_todo
        ;;
    "log")
        # Validate arguments before proceeding
        shift
        if ! validate_command_args "log" "$@"; then
            exit 1
        fi
        if [[ "$1" == "--filter" && -n "$2" ]]; then
            view_log "$2" "$3"
        elif [[ "$1" == "--lines" && -n "$2" ]]; then
            view_log "" "$2"
        else
            view_log
        fi
        ;;
    "update")
        update_tool
        ;;
    "backups"|"list-backups")
        list_backups
        ;;
    "rollback")
        shift
        rollback "$@"
        ;;
    "report-bug")
        shift
        report_bug "$1" "$2" "$3"
        ;;
    "uninstall")
        shift
        uninstall_tool "$@"
        ;;
    "switch-mode")
        shift
        switch_mode "$@"
        ;;
    "list-mode-backups")
        list_mode_backups
        ;;
    "rollback-mode")
        shift
        rollback_from_backup "$1"
        ;;
    "config"|"show-config")
        show_config
        ;;
    "detect-coordination"|"detect-options")
        detect_coordination_options
        ;;
    "setup-coordination")
        shift
        setup_coordination "$@"
        ;;
    "setup"|"setup-wizard")
        setup_wizard
        ;;
    "version"|"--version"|"-v")
        echo "todo.ai version $VERSION"
        echo "Repository: $REPO_URL"
        echo "Update: ./todo.ai update"
        ;;
    "--info")
        show_usage
        local config_file=$(get_config_file)
        echo ""
        echo "Config file location: $config_file"
        ;;
    "--help"|"help"|"-h")
        show_usage
        ;;
    *)
        show_usage
        ;;
esac